# Base R {#sec-r-baser .unnumbered}

## Misc {#sec-r-baser-misc .unnumbered}

-   Packages

    -   [{]{style="color: #990000"}[poorman](https://nathaneastwood.github.io/poorman/){style="color: #990000"}[}]{style="color: #990000"} - Dependency free versions of [{dplyr}]{style="color: #990000"} verbs that help you solve the most common data manipulation challenges

-   Magrittr + base

    ``` r
    mtcars %>% {plot(.$hp, .$mpg)}
    mtcars %$% plot(hp, mpg)
    ```

    -   By wrapping the RHS in curly braces, we can override the rule where the LHS is passed to the first argument \## Options {#sec-r-baser-opts .unnumbered}

-   Remove scientific notation

    ``` r
    options(scipen = 999)
    ```

-   Wide and long printing tibbles

    ``` r
    # in .Rprofile
    makeActiveBinding(".wide", function() { print(.Last.value, width = Inf) }, .GlobalEnv)
    ```

    -   After printing a tibble, if you want to see it in wide, then just type .wide + ENTER.
    -   Can have similar bindings for \`.long\` and \`.full\`.

-   Heredocs - Powerful feature in various programming languages that allow you to define a block of text within the code, preserving line breaks, indentation, and other whitespace.

    ``` r
    text <- r"(
    This is a
    multiline string
    in R)"

    cat(text)
    ```

-   Selective function importing (R $\ge$ 4.0) ([source](https://bsky.app/profile/jrgant.bsky.social/post/3ld2uslshws2n))

    ``` r
    library(stringr, include.only = c("str_extract", "str_remove"))
    ```

-   Super Assignment (`<<-)`

    -   It never creates a variable in the current environment, but instead modifies an existing variable found in a *parent* environment
    -   If `<<-` doesn’t find an existing variable, it will create one in the global environment.
    -   Most often used in conjunction with a function factory (See [Advanced R, Sect. 10.2.4](https://adv-r.hadley.nz/function-factories.html#stateful-funs))

## Downloading, Reading, and Writing {#sec-r-baser-raw .unnumbered}

-   Set internet timeout value

    -   Environment variable

        ```         
        R_DEFAULT_INTERNET_TIMEOUT=300
        ```

    -   Options

        ``` r
        options(timeout = max(300, getOption("timeout")))
        ```

-   Downloading and reading .rda and .RData via URL

    ``` r
    # option 1
    pop_url <- url("https://raw.githubusercontent.com/edzer/sdsr/main/data/ch12.rda")
    load(pop_url)

    # option 2
    url <- "https://raw.githubusercontent.com/edzer/sdsr/main/data/ch12.rda"
    destfile <- tempfile(fileext = ".rda")
    download.file(url, destfile, mode = "wb")
    load(destfile)

    # option 3
    dat_de_pop <- local({ 
      load(url("https://raw.githubusercontent.com/edzer/sdsr/main/data/ch12.rda"), 
           envir = environment()) 
      if (length(ls()) > 1) {
        mget(ls())
      } else {
        get(ls()[1])
      }
    })
    ```

    -   `load` will not allow you to assign the loaded object to a name of your choosing, i.e. `moose <- load(moose.rda)` will not work.
    -   `local` creates a temporary evaluation environment and ensures no stray variables remain in your workspace
    -   `load(..., envir = environment())` loads the `.rda` contents into the local environment created by `local`
    -   `ls(e)[1]` retrieves the (first) object name that was loaded into the local environment.
    -   `get` extracts the actual object from that environment.
    -   `mget` accepts a character vector of object names. So, if the .rda file contains multiple objects, this function will load them all in a list.

-   Download multiple files

    ``` r
    urls <- 
      c("https://ereporting.blob.core.windows.net/downloadservice/NL_8_28027_2017_timeseries.csv",
        "https://ereporting.blob.core.windows.net/downloadservice/NL_8_28145_2017_timeseries.csv"
    )

    dest_dir <- "C:/Users/user/Documents/R/Data/no2/raw"
    dir.create(dest_dir, recursive = TRUE, showWarnings = FALSE)

    dest <- file.path(dest_dir, basename(urls))

    # Download with a polite delay between requests
    for(i in seq_along(urls)) {
      download.file(urls[i], 
                    destfile = dest[i],
                    mode = "wb") # windows

      # Wait 1-2 seconds between downloads
      if(i < length(urls)) {
        Sys.sleep(1)
      }
    }
    ```

-   Reading in zipped files ([source](https://bsky.app/profile/andrew.heiss.phd/post/3ln4abydszs25))

    ``` r
    # unz() lets you read one file from a .zip
    one_zipped_csv_among_others <- readr::read_csv(
      unz("lotsa_zipped_csvs.zip", "one_csv.csv")
    )

    # .zip with a single CSV
    one_zipped_csv <- readr::read_csv("big_zipped_file.zip")
    ```

## User Defined Functions {#sec-r-baser-usrfuns .unnumbered}

-   Anonymous (aka lambda) functions: `\(x) {}` (\> R 4.1)

    ``` r
    function(x) {
      x[which.max(x$mpg), ]
    }
    # equivalent to the above
    \(x) {
      x[which.max(x$mpg), ]
    }
    ```

-   Define and call an anonymous function at the same time

    ``` r
    n <- c(1:10)
    moose <- (\(x) x+1)(n)
    moose
    #> [1]  2  3  4  5  6  7  8  9 10 11
    ```

-   Dots (...)

    -   Misc

        -   Packages
            -   [{]{style="color: #990000"}[ellipsis](https://ellipsis.r-lib.org/){style="color: #990000"}[}]{style="color: #990000"}: Functions for testing functions with dots so they fail loudly
        -   Resources
            -   Video: [Demystifying . . . (dots): R package dev fundamentals](https://www.youtube.com/watch?v=oIMFZf5dUFA) (Parry)
            -   [Advanced R, Ch 6.6](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot)
            -   [{rlang}]{style="color: #990000"} dynamic dots: [article](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbkxlZk41V2RjNndZdXU5ZElqOGhUcnhJR01Md3xBQ3Jtc0ttMS1aekRNekdTc0h4Zk1KZGMtNkg2c2ZISk5DcjcwcXhVRTZianZORmppNDV2ZDE3bWNLNmtqNVA3eDFlMHNsdGYzWDlBZ2VQNHBBZGF1YWtZdWdJSmIzeHRtNVNDSmg5RGJhT1NCZTJFRXItcDhrZw&q=https%3A%2F%2Frlang.r-lib.org%2Freference%2Fdyn-dots.html&v=oIMFZf5dUFA)
                -   Splice arguments saved in a list with the splice operator, `!!!` .
                -   Inject names with glue syntax on the left-hand side of `:=` .

    -   Basic Usage

        ``` r
        my_data_frame <- function(...) {
          dots <- list(...)
          dots_names <- names(dots)

          if (is.null(dots_names) || "" %in% dots_names) {
            stop("all arguments must be named")
          }

          list2DF(dots)
        }
        # errors b/c args not named
        my_data_frame(1:10, letters[1:10])
        # works
        data_frame(id = 1:10, alphabet = letters[1:10])
        ```

    -   Some forms I've used *inside* UDFs

        ``` r
        dots <- list(...) # <1>
        init_boot_args <-
          list(data = dynGet("data"),
               stat_fun = cles_boot, # internal function
               group_variables = group_variables,
               paired = paired)
        get_boot_args <-
          append(init_boot_args,
                 dots)

        grp_tbl <- .tbl %>% dplyr::group_by(...) # <2>

        .data |> # <3>
          dplyr::reframe({{ array_name }} := purrr::pmap(list(!!!dots), ~list(...)),
                         .by = {{ .grp_var }})
        ```

        1.  From [{]{style="color: #990000"}[ebtools::get_boot_ci](https://github.com/ercbk/ebtools/blob/master/R/get-boot-ci.R){style="color: #990000"}[}]{style="color: #990000"}
        2.  From [{]{style="color: #990000"}[ebtools::add_mase_scale_feat](https://github.com/ercbk/ebtools/blob/master/R/add-mase-scale-feat.R){style="color: #990000"}[}]{style="color: #990000"}
        3.  From [{]{style="color: #990000"}[ebtools::to_json_array](https://github.com/ercbk/ebtools/blob/master/R/to-js-array.R){style="color: #990000"}[}]{style="color: #990000"}

    -   Some tests I used

        ``` r
        moose <- function(...) {
          dots <- list(...)
          dots_names <- names(dots)
          if (is.null(dots_names) || "" %in% dots_names {
            stop("All arguments must be named")
          }


          dots <- rlang::enquos(..., .named = TRUE)
          # group column(s) required
          chk::chk_not_empty(dots, x_name = "... (group columns)")


          accepted_styles <- c("W", "B", "C", "S", "U", "minmax", "raw")
          dots <- list(...)
          # Check if "style" is provided in ... and validate
          if ("style" %in% names(dots)) {
            chk::chk_subset(dots$style, 
                            accepted_styles, 
                            x_name = "style")
          }
        }
        ```

    -   Nested Functions

        ``` r
        f02 <- function(...){
          vv <- list(...)
          print(vv)
        }
        f01 <- function(...){
          f02(b = 2,...)
        }

        f01(a=1,c=3)
        #> $b
        #> [1] 2
        #> 
        #> $a
        #> [1] 1
        #> 
        #> $c
        #> [1] 3
        ```

    -   Subset dots values

        ``` r
        add2 <- function(...) {
          ..1 + ..2
        }
        add2(3, 0.14)
        # 3.14
        ```

    -   Subset dots dynamically: `...elt(n)`

        -   Assign a value to [n]{.arg-text} and get back the value of that argument
        -   A programmatic way to subset instead of the hard coding way (i.e. `..1`)

    -   Number of arguments in ... : `...length()`

## Functions {#sec-r-baser-funs .unnumbered}

-   `aggregate`
    -   `aggregate(x, by, FUN)`

        -   Can also take a formula, `x ~ group`
        -   [drop = TRUE]{.arg-text} means that any groups with zero count are removed.
        -   [na.action]{.arg-text} controls the treatment of missing values within the data.

    -   Mean for combinations of two groups

        ``` r
        aggregate(df$points, by=list(df$team, df$position), FUN=mean)

        #>   Group.1 Group.2    x
        #> 1       A       F 86.0
        #> 2       B       F 97.0
        #> 3       A       G 94.5
        #> 4       B       G 88.0
        ```

    -   Count distinct values per group ([source](https://www.spsanderson.com/steveondata/posts/2023-08-10/index.html))

        ``` r
        data("mtcars")

        group_counts <- aggregate(
          data = mtcars, 
          carb ~ cyl, 
          FUN = function(x) length(unique(x))
          )
        group_counts
        #>   cyl carb
        #> 1   4    2
        #> 2   6    3
        #> 3   8    4
        ```

        -   [cyl]{.var-text} and [carb]{.var-text} are discrete
        -   Groups by the [cyl]{.var-text} variable and applies the `length` and `unique` to count the number of distinct [carb]{#.var-text} per [cyl]{.var-text} group

    -   Adding function arguments

        ``` r
        dat <- aggregate(tserie ~ month(index(tserie)), 
                         FUN = quantile,
                         probs = c(0.05, 0.95))
        colnames(dat)[1] <- "Month"
        dat
        #>  Month    V1.5%      V2.95%
        #>    1   -1.7041221   1.2301178
        #>    2   -0.9388331   1.7888182
        #>    3   -1.3886001   1.5261942
        #>    4   -1.0834517   1.5697239
        #>    5   -1.6527890   1.0883061
        #>    6   -1.4064641   2.1472166
        ```

    -   Sum of multiple variables for combinations of groups ([source](https://www.r-bloggers.com/2015/11/aggregate-a-powerful-tool-for-data-frame-in-r/))

        ``` r
        exposures <- aggregate(x = assets[c("counterparty.a", 
                                            "counterparty.b",
                                            "counterparty.c")],
                               by = assets[c("asset.class", "rating")],
                               FUN = function(market.values){
                                       sum(pmax(market.values, 0))
                                     })
        exposures
        #>   asset.class rating counterparty.a counterparty.b counterparty.c
        #> 1        bond      A      1.0038714      0.6382029      2.2822936
        #> 2      equity      A      0.9841620      1.5178126      0.7745532
        #> 3        bond    AAA      0.0000000      0.0000000      0.0000000
        #> 4      equity    AAA      0.9026004      0.6029417      0.8629453
        ```
-   `ave`
    -   Sort of `group_by` + `mutate` ([source](https://fosstodon.org/@_wurli/113075284452623779))

        ``` r
        x <- c(1, 2, 3, 1, 2, 3, 3, 3)
        y <- c(1, 1, 1, 1, 2, 2, 2, 2)

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # 1. Sum over `x` using `y` as a 'grouping' variable
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ave(x, y, FUN = sum)
        #> [1] 7 7 7 7 11 11 11 11

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # 2. Number of distinct elements in each group
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ave(x, y, FUN = dplyr::n_distinct)
        #> [1] 3 3 3 3 2 2 2 2

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # 3. Number of times each element of `x` appears
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ave(x, x, FUN = length)
        #> [1] 2 2 4 2 2 4 4 4

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # 4. Indicating how many times each element has occurred so far
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        x <- c("a", "a", "b", "a", "b", "c")
        paste0(x, ave(x, x, FUN = seq_along))
        #> [1] "a1" "a2" "b1" "a3" "b2" "c1"
        ```

        1.  Group by "1" and sum. So all the x values that have the same index as y = 1 sum to: 7 = 1 + 2 + 3 + 1. For each y = 1, that calculation is made, so there are 4 sevens.
        2.  Group by "1" and find the number of distinct values. There are 3 distinct values of x when y = 1: 1, 2, and 3.
        3.  x is used for each input. It counts how many times the value appears in the vector. 1 occurs twice, 2 occurs twice, and 3 occurs four times.
        4.  Instead of a total like in the previous example, `seq_along` creates a cumulative count for each value.
-   `capture.output`
    -   Stores the output from a print method

        ``` r
        summ_wts <- capture.output(spdep:::print.listw(ls_wts))
        cat(summ_wgts, sep = "\n")
        ```

        -   From [{]{style="color: #990000"}[ebtools::add_spatial_lags](https://github.com/ercbk/ebtools/blob/master/R/add-spatial-lags.R){style="color: #990000"}[}]{style="color: #990000"}

        -   `print.listw` prints a nice summary of spatial weights information but if you try to save it to a variable, it saves the actuall weight list object. So, `capture.output` allows you to save the summary text.
-   `do.call` - allows you to call other functions by constructing the function call as a list
    -   Args

        -   what -- Either a function or a non-empty character string naming the function to be called
        -   args -- A list of arguments to the function call. The names attribute of args gives the argument names
        -   quote -- A logical value indicating whether to quote the arguments
        -   envir -- An environment within which to evaluate the call. This will be most useful if what is a character string and the arguments are symbols or quoted expressions

    -   [Example]{.ribbon-highlight}: Apply function to list of vectors

        ``` r
        vectors <- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))
        combined_matrix <- do.call(rbind, vectors)

        combined_matrix
        ##      [,1] [,2] [,3]
        ## [1,]    1    2    3
        ## [2,]    4    5    6
        ## [3,]    7    8    9
        ```

    -   [Example]{.ribbon-highlight}: Apply multiple functions

        ``` r
        data_frames <- list(
          data.frame(a = 1:3), 
          data.frame(a = 4:6), 
          data.frame(a = 7:9)
          )
        mean_results <- do.call(
          rbind, 
          lapply(data_frames, function(df) mean(df$a))
          )

        mean_results
        ##      [,1]
        ## [1,]    2
        ## [2,]    5
        ## [3,]    8
        ```

        -   First the mean is calculated for column a of each df using `lapply`
            -   `lapply` is supplying the data for `do.call` in the required format, which is a list or character vector.
        -   Second the results are combined into a matrix with `rbind`
-   `dynGet`
    -   Looks for objects in the environment of a function.

    -   When an object from the outer function is an input for a function nested around 3 layers deep or more, it may not be found by that most inner function. `dynGet` allows that function to find the object in the outer frame

    -   Arguments

        -   [minframe]{.arg-text}: Integer specifying the minimal frame number to look into (i.e. how far back to look for the object)

        -   [inherits]{.arg-text}: Should the enclosing frames of the environment be searched?

    -   [Example]{.ribbon-highlight}:

        ``` r
        function(args) {  # <1>
          if (method == "kj") {
              ncv_list <- purrr::map2(grid$dat, 
                                      grid$repeats, 
                                      function(dat, reps) {
                 rsample::nested_cv(dat,
                                    outside = vfold_cv(v = 10, 
                                                       repeats = dynGet("reps")),
                                    inside = bootstraps(times = 25))
              })
          }
        }

        function(data) {  # <2>
            if (chk::vld_used(...)) {
                dots <- list(...)
                init_boot_args <-
                  list(data = dynGet("data"),
                       stat_fun = cles_boot, # internal function
                       group_variables = group_variables,
                       paired = paired)
                get_boot_args <-
                  append(init_boot_args,
                         dots)
            }
            cles_booted <-
              do.call(
                get_boot_ci,
                get_boot_args
              )
        }
        ```

        1.  Example from [Nested Cross-Validation Comparison](https://github.com/ercbk/nested-cross-validation-comparison/blob/5f5b8503a3f74565491df39d668b8c6485035071/performance-experiment/functions/create-ncv-objects.R#L29C71-L29C71)
        2.  Example from [{]{style="color: #990000"}[ebtools::cles](https://github.com/ercbk/ebtools/blob/764db168609b0f8639b59d09ef78cc90186c293b/R/cles.R#L74){style="color: #990000"}[}]{style="color: #990000"}
            -   `get_boot_ci()` wraps another function that requires [data]{.var-text} as an input
-   `invisible`
    -   In some functions, you only want the side effect, so there is no value to return. In that case, R will return (and print) the first input (?).

        -   When a function returns a value *without it being assigned to a variable*, R's REPL will automatically print that returned value to the console.
        -   To prevent this action, you use `invisible` around the input of the function.

    -   Any function called primarily for a side effect (like `<-`, `print()`, or `plot()`) should return an invisible value (typically the value of the first argument). ([Advanced R, Ch. 6.7.2](https://adv-r.hadley.nz/functions.html?q=invisible#invisible))

    -   For a custom `print` method, If you don't include `invisible`, R would print the entire, unformatted object to the console right after your custom output. This results in a cluttered and confusing double output

    -   [Example]{.ribbon-highlight}: ebtools::skim_arrow

        ``` r
        print.skim_arrow <- function(x, ...) {
          cat("── Data Summary ──\n\n")
          print(x$overview)

          if (!is.null(x$numeric)) {
            cat("\n── Numeric Variables ──\n\n")
            print(x$numeric, n = Inf)
          }

          if (!is.null(x$character)) {
            cat("\n── Character Variables ──\n\n")
            print(x$character, n = Inf)
          }

          if (!is.null(x$timestamp)) {
            cat("\n── Timestamp Variables ──\n\n")
            print(x$timestamp, n = Inf)
          }

          invisible(x)
        }
        ```
-   `match`
    -   Returns a *vector of the positions* of (first) matches of its first argument in its second argument.

    -   [Example]{.ribbon-highlight}: Reorder rows of a df to match the order of the columns in another df ([source](https://cran.r-project.org/web/packages/spacetime/vignettes/jss816.pdf))

        ``` r
        names(wind[4:15])
        #>  [1] "RPT" "VAL" "ROS" "KIL" "SHA" "BIR" "DUB" "CLA" "MUL" "CLO" "BEL" "MAL"

        wind.loc@data
        #>          Station Code       Latitude     Longitude MeanWind
        #> 1       Valentia  VAL        51d56'N       10d15'W     5.48
        #> 2      Belmullet  BEL        54d14'N       10d00'W     6.75
        #> 3    Claremorris  CLA        53d43'N        8d59'W     4.32
        #> 4        Shannon  SHA        52d42'N        8d55'W     5.38
        #> 5  Roche's Point  RPT        51d48'N        8d15'W     6.36
        #> 6           Birr  BIR        53d05'N        7d53'W     3.65
        #> 7      Mullingar  MUL        53d32'N        7d22'W     4.38
        #> 8     Malin Head  MAL        55d22'N        7d20'W     8.03
        #> 9       Kilkenny  KIL        52d40'N        7d16'W     3.25
        #> 10        Clones  CLO        54d11'N        7d14'W     4.48
        #> 11        Dublin  DUB        53d26'N        6d15'W     5.05
        #> 12       Roslare  ROS 52d16'56.791"N 6d21'25.056"W     6.00

        match(names(wind[4:15]), wind.loc$Code)
        #>  [1]  5  1 12  9  4  6 11  3  7 10  2  8

        wind.loc1 = wind.loc[match(names(wind[4:15]), wind.loc$Code),]
        wind.loc1@data
        #>          Station Code       Latitude     Longitude MeanWind
        #> 5  Roche's Point  RPT        51d48'N        8d15'W     6.36
        #> 1       Valentia  VAL        51d56'N       10d15'W     5.48
        #> 12       Roslare  ROS 52d16'56.791"N 6d21'25.056"W     6.00
        #> 9       Kilkenny  KIL        52d40'N        7d16'W     3.25
        #> 4        Shannon  SHA        52d42'N        8d55'W     5.38
        #> 6           Birr  BIR        53d05'N        7d53'W     3.65
        #> 11        Dublin  DUB        53d26'N        6d15'W     5.05
        #> 3    Claremorris  CLA        53d43'N        8d59'W     4.32
        #> 7      Mullingar  MUL        53d32'N        7d22'W     4.38
        #> 10        Clones  CLO        54d11'N        7d14'W     4.48
        #> 2      Belmullet  BEL        54d14'N       10d00'W     6.75
        #> 8     Malin Head  MAL        55d22'N        7d20'W     8.03
        ```

        -   We see that [RPT]{.var-text} is the first column in [wind]{.var-text}, and it matches the 5th row in [wind.loc]{.var-text}'s [Code]{.var-text} column
-   `match.arg`
    -   Partially matches a function's argument values to list of choices. If the value doesn't match the choices, then an error is thrown

    -   [Example]{.ribbon-highlight}:

        ``` r
        keep_input <- "input_le"
        keep_input_val <- 
          match.arg(keep_input,
                    choices = c("input_lags",
                                "input_leads",
                                "both"),
                    several.ok = FALSE)
        keep_input_val
        #> [1] "input_leads"
        ```

        -   [several.ok = FALSE]{.arg-text} says only 1 match is allowed otherwise an error is thrown.
        -   The error message is pretty informative btw.
-   `match.fun`
    -   [Example]{.ribbon-highlight}

        ``` r
        f <- function(a,b) {
          a + b
        }
        g <- function(a,b,c) {
          (a + b) * c
        }
        h <- function(d,e) {
          d - e
        }
        yolo <- function(FUN, ...) {
          FUN <- match.fun(FUN)
          params <- list(...)
          FUN_formals <- formals(FUN)
          idx <- names(params) %in% names(FUN)
          do.call(FUN, params[idx])
        }
        yolo(h, d = 2, e = 3)
        #> -1
        ```
-   `Negate`
    -   Creates a negation of a given function. Can replace `!` for easier recognition.

    -   [Example]{.ribbon-highlight}: Removing NULLs from a list ([source](https://fosstodon.org/@tim_salabim/113584843354400565))

        ``` r
        Filter(
              Negate(is.null),
              list(...)
        )
        ```
-   `outer`
    -   Stands for "outer product" which is it's default, but it doesn't have to be a product. I can be any operation

    -   Basic

        ``` r
        outer(X = c(0, 5), Y = 1:5) # FUN = "*" by default
        #>      [,1] [,2] [,3] [,4] [,5]
        #> [1,]    0    0    0    0    0
        #> [2,]    5   10   15   20   25

        outer(c(0, 5), 1:5, FUN = "+")
        #>      [,1] [,2] [,3] [,4] [,5]
        #> [1,]    1    2    3    4    5
        #> [2,]    6    7    8    9   10
        ```

        -   A row is the result of applying the function to an element of [X]{.arg-text} and each element of [Y]{.arg-text}

            -   e.g. The first row the outer product is 0 \* 1, 0 \* 2, 0 \* 3, 0 \* 4, 0 \* 5.

    -   Lags

        ``` r
        dat <- data.frame(x = seq(1,5))
        outer(-1:1, dat[which(dat$x == 3), ], `+`)
        #>      [,1]
        #> [1,]    2
        #> [2,]    3
        #> [3,]    4

        outer(-1:1, 
              which(country == "Germany"), 
              `+` ))
        #> [1]  2 14 19 25 26 28 33 38 39 62 65 66 92 93
        #> [1]  3 15 20 26 27 29 34 39 40 63 66 67 93 94
        #> [1]  4 16 21 27 28 30 35 40 41 64 67 68 94 95
        ```

        -   In the first situation, the first row is -1 plus the index for x = 3 (which is 3), so this give the index before the index of x = 3

        -   In the second second situation, the first row is -1 plus the index for *each* instance of [country == "Germany"]{.arg-text}, so it's the previous row index.

            -   This second situation is something I plucked out of the middle of a chain of code, so it's doesn't make exact sense on it's own. (See [R, Snippets \>\> Cleaning](r-snippets.qmd#sec-r-snippets-cleaning){style="color: green"} \>\> Filter row index before/after a condition \>\> Example 2 for the complete code)

        -   Each column of the matrix is the indexes for the before, actual, and after values for each instance of [country == "Germany"]{.arg-text}.

        -   This example doesn't involve time, but you can see how each column could be a window of t-1, t, and t+1. Then window calculations can be done column-wise which is R's forte. (See [R, Snippets \>\> Calculations \>\> Time Series \>\> Base R](r-snippets.qmd#sec-r-snippets-calcs-ts-baser){style="color: green"} \>\>Moving Windows for an example)
-   `pmin` and `pmax`
    -   Find the element-wise maximum and minimum values across vectors in R

    -   [Example]{.ribbon-highlight}

        ``` r
        vec1 <- c(3, 9, 2, 6)
        vec2 <- c(7, 1, 8, 4)
        pmax(vec1, vec2)
        #> [1] 7 9 8 6
        pmin(vec1, vec2)
        #> [1] 3 1 2 4
        ```

    -   [Example]{.ribbon-highlight}: With NAs

        ``` r
        data1 <- c(7, 3, NA, 12)
        data2 <- c(9, NA, 5, 8)
        pmax(data1, data2, na.rm = TRUE)
        #> [1] 9 3 5 12
        ```
-   `sink` - used to divert R output to an external connection.
    -   Use Cases: exporting data to a file, logging R output, or debugging R code.

    -   Args

        -   file: The name of the file to which R output will be diverted. If file is NULL, then R output will be diverted to the console.
        -   append: A logical value indicating whether R output should be appended to the file (TRUE) or overwritten (FALSE). The default value is FALSE.
        -   type: A character string. Either the output stream or the messages stream. The name will be partially match so can be abbreviated.
        -   split: logical: if TRUE, output will be sent to the new sink and the current output stream, like the Unix program tee.

    -   [Example]{.ribbon-highlight}: Logging output of code to file

        ``` r
        sink("r_output.log")      # Redirect output to this file
        # Your R code goes here
        sink()                    # Turn off redirection
        ```

        -   output file could also have an extension like ".txt"

    -   [Example]{.ribbon-highlight}: Debugging

        ``` r
        sink("my_function.log")   # Redirect output to this file
        my_function()
        sink()                    # Turn off redirection
        ```

    -   [Example]{.ribbon-highlight}: Appending output to a file

        ``` r
        sink("output.txt", append = TRUE)  # Append output to the existing file
        cat("Additional text\n")  # Append custom text
        plain text
        sink()  # Turn off redirection
        ```
-   `switch`
    -   [Example]{.ribbon-highlight}: ([source](https://github.com/ercbk/ebtools/blob/80de6546bcdef78f28e270a250646a8ffd624fcc/R/get-boot-ci.R#L139))

        ``` r
        switch(parallel,
               windows = "snow" -> para_proc,
               other = "multicore" -> para_proc,
               no = "no" -> para_proc,
               stop(sprintf("%s is not one of the 3 possible parallel argument values. See documentation.", parallel)))
        ```

        -   [parallel]{.arg-text} is the function argument. If it doesn't match one of the 3 values ([windows]{.arg-text}, [other]{.arg-text}, or [no]{.arg-text}), then an error is thrown.
        -   If the argument value is matched, then the quoted value is stored in [para_proc]{.var-text}
-   `within`
    -   Evaluate a R expression in an environment constructed from data, possibly modifying (a copy of) the original data.

        -   i.e. acts similar to `dplyr::mutate` and `transform`
            -   `transform` cannot refer to variables previously created in the same transformation
        -   Docs also show putting boxplot code in the braces.

    -   [Example]{.ribbon-highlight}: ([source](https://luis.apiolaza.net/2023/03/18/some-love-for-base-r-part-1/))

        ``` r
        gw <- gw |> within({ 
          dratio <- dia1.mm/dia2.mm
          dia <- ifelse(is.na(dia2.mm), 
                        dia1.mm, (dia1.mm + dia2.mm)/2)
          slend <- ht.cm / dia
          smoe <- 1.1 * v2104^2
          gmoe <- 1.1 * vgreen^2
          dmoe <- (bden / 1000) * 1.14 * vdry^2
        })
        ```

## Pipe {#sec-r-baser-pipe .unnumbered}

![](./_resources/R-Base-R.resources/image.png)

-   Benefits of base pipe

    -   Magrittr pipe is bloated with special features which may make it slower than the base pipe
    -   If not using tidyverse, it's one less dependency (maybe one day it will be deprecated in tidyverse)

-   Base pipe with base and anonymous functions

    ``` r
    # verbosely
    mtcars |> (function(.) plot(.$hp, .$mpg))()
    # using the anonymous function shortcut, emulating the dot syntax
    mtcars |> (\(.) plot(.$hp, .$mpg))()
    # or if you prefer x to .
    mtcars |> (\(x) plot(x$hp, x$mpg))()
    # or if you prefer to be explicit with argument names
    mtcars |> (\(data) plot(data$hp, data$mpg))()
    ```

-   Using "\_" placeholder:

    -   `mtcars |> lm(mpg ~ disp, data = _)`
    -   `mtcars |> lm(mpg ~ disp, data = _) |> _$coef`

-   Base pipe .\[ \]  hack

    ``` r
    wiki |>
      read_html() |>
      html_nodes("table") |>
      (\(.) .[[2]])() |>
      html_table(fill = TRUE) |>
      clean_names()
    # instead of
    djia <- wiki %>%
      read_html() %>%
      html_nodes("table") %>%
      .[[2]] %>%
      html_table(fill = TRUE) %>%
      clean_names()
    ```

-   Magrittr, base pipe differences ([source](https://stackoverflow.com/a/72086492/8820422))\
    ![](_resources/R-Base-R.resources/pipe-diffs-1.jpg){.lightbox width="583"}

    -   magrittr: `%>%` allows you change the placement with a `.` placeholder.
        -   base: R 4.2.0 added a `_` placeholder to the base pipe, with one additional restriction: the argument has to be named
    -   magrittr: With `%>%` you can use `.` on the left-hand side of operators like `$`, `[[`, `[` and use in multiple arguments (e.g. `df %>% {split(.$x, .$y)}`)
        -   base: can hack this by using anonymous function
            -   See Base pipe with base and anonymous functions above
            -   See Base pipe `.[ ]` hack above
    -   magrittr: `%>%` allows you to drop the parentheses when calling a function with no other arguments (e.g. dat %\>% distinct)
        -   base: `|>` always requires the parentheses. (e.g. `dat`\|\> distinct()\`)
    -   magrittr: `%>%` allows you to start a pipe with `.` to create a function rather than immediately executing the pipe

-   Purrr with base pipe

    ``` r
    data_list |>
      map(\(x) clean_names(x))
    # instead of
    data_list %>%
      map( ~.x %>% clean_names)
    # with split
    star |>
      split(~variable) |>
      map_df(\(.) hedg_g(., reading ~ value), .id = "variable")
    # instead of
    star %>%
      split(.$variable) %>%
      map_df(. %>% hedg_g(., reading ~ value), .id = "variable")
    ```

## Strings {#sec-r-baser-str .unnumbered}

-   Resources

    -   [From base R](https://stringr.tidyverse.org/articles/from-base.html) - base R equivalents to [{stringr}]{style="color: #990000"} functions

-   `sprintf`

    ``` r
    x <- 123.456               # Create example data

    sprintf("%f", x)           # sprintf with default specification
    #> [1] "123.456000"

    sprintf("%.10f", x)        # sprintf with ten decimal places
    #> [1] "123.4560000000"

    sprintf("%.2f", x)         # sprintf with two rounded decimal places
    #> [1] "123.46"

    sprintf("%1.0f", x)        # sprintf without decimal places
    #> [1] "123"

    sprintf("%10.0f", x)       # sprintf with space before number
    #> [1] "       123"

    sprintf("%10.1f", x)       # Space before number & decimal places
    #> [1] "     123.5"

    sprintf("%-15f", x)        # Space on right side
    #> [1] "123.456000     "

    sprintf("%+f", x)          # Print plus sign before number
    #> [1] "+123.456000"

    sprintf("%e", x)           # Exponential notation
    #> [1] "1.234560e+02"

    sprintf("%E", x)           # Exponential with upper case E
    #> [1] "1.234560E+02"

    sprintf("%g", x)           # sprintf without decimal zeros
    #> [1] "123.456"

    sprintf("%g", 1e10 * x)    # Scientific notation
    #> [1] "1.23456e+12"

    sprintf("%.13g", 1e10 * x) # Fixed decimal zeros
    #> [1] "1234560000000"

    paste0(sprintf("%f", x),   # Print %-sign at the end of number
           "%")
    #> [1] "123.456000%"

    sprintf("Let's create %1.0f more complex example %1.0f you.", 1, 4)
    #> [1] "Let's create 1 more complex example 4 you."
    ```

    -   [Example]{.ribbon-highlight}: Add leading zeros ([source](https://www.spsanderson.com/steveondata/posts/2024-06-18/))

        ``` r
        numbers <- c(1, 23, 456)
        formatted_numbers <- sprintf("%05d", numbers)
        print(formatted_numbers)
        #> [1] "00001" "00023" "00456"

        mixed_input <- c(12, "abc", 345)
        formatted_mixed_input <- ifelse(
          is.na(as.numeric(mixed_input)), 
          mixed_input, 
          sprintf("%05d", as.numeric(mixed_input))
          )
        print(formatted_mixed_input)
        #> [1] "00012" "abc"   "00345"
        ```

-   `str2lang` - Allows you to turn plain text into code.

    ``` r
    growth_rate <- "circumference / age"
    class(str2lang(growth_rate))
    #> [1] "call"
    ```

    -   [Example]{.ribbon-highlight}: Basic

        ``` r
        eval(str2lang("2 + 2"))
        #> [1] 4

        eval(str2lang("x <- 3"))
        x
        #> [1] 3
        ```

    -   [Example]{.ribbon-highlight}: Run formula against a df

        ``` r
        growth_rate <- "circumference / age"
        with(Orange, eval(str2lang(growth_rate)))

        #>   [1] 0.25423729 0.11983471 0.13102410 0.11454183 0.09748172 0.10349854
        #>   [7] 0.09165613 0.27966102 0.14256198 0.16716867 0.15537849 0.13972380
        #>  [13] 0.14795918 0.12831858 0.25423729 0.10537190 0.11295181 0.10756972
        #>  [19] 0.09341998 0.10131195 0.08849558 0.27118644 0.12809917 0.16867470
        #>  [25] 0.16633466 0.14541024 0.15233236 0.13527181 0.25423729 0.10123967
        #>  [31] 0.12198795 0.12450199 0.11535337 0.12682216 0.11188369
        ```

-   `agrep` - Fuzzy Matching ([source](https://www.spsanderson.com/steveondata/posts/2024-08-29/))

    -   Syntax

        ``` r
        agrep(
          pattern, 
          x, 
          max.distance = 0.1, 
          ignore.case = FALSE, 
          value = FALSE, 
          fixed = TRUE
          )
        ```

        -   [pattern]{.arg-text}: The string pattern you want to match
        -   [x]{.arg-text}: The vector of strings to search within
        -   [max.distance]{.arg-text}: The maximum allowed distance for a match
            -   If integer, then the integer is the number of characters that can be wrong
            -   If decimal, (0,1), then it's the percentage of characters than can be wrong
        -   [ignore.case]{.arg-text}: Whether to ignore case when matching
        -   [value]{.arg-text}: Whether to return the matched values instead of indices
        -   [fixed]{.arg-text}: Whether to treat the pattern as a fixed string or a regular expression

    -   [Examples]{.ribbon-highlight}

        ``` r
        agrep("aardvark", # <1>
              c(" 1 ardvarc 2", "1 lasy 2"), 
              max.distance = 2) 
        #> [1] 1

        agrep("aardvark", # <2>
              c(" 1 arbvarc 2", "1 lasy 2"), 
              max.distance = 2) 
        #> integer(0)

        agrep("lasy", # <3>
              c(" 1 lazy 2", "1 lasy 2"), 
              max.distance = 0.25) 
        #> [1] 1 2
        ```

        1.  The first string is missing an "a" and has a "c" where the "k" should be. Therefore, it's within 2 characters of being correct which equals [max.distance]{.arg-text}, so it gets matched. The output is 1 which indicates the first string.
        2.  The first string is missing an "a", has a "c" where the "k" should be, and has a "b" where a "d" should be. Therefore, it's 3 characters away from being correct which is outside the [max.distance]{.arg-text}. String 2 isn't close, so nothing gets matched. The output is 0 which indicates the none of the vector indexes has a match.
        3.  The first string has a "z" where the "s" should be and the second string matches exactly. The [max.distance]{.arg-text} is a quarter of the pattern which is 1 character. Therefore, both strings get matched.

## Conditionals {#sec-r-baser-cond .unnumbered}

-   && and \|\| are intended for use *solely* with scalars, they return a single logical value.

    -   Since they always return a scalar logical, you should use && and \|\| in your if/while conditional expressions (when needed). If an & or \| is used, you may end up with a non-scalar vector inside if (...) {} and R will throw an error.

-   & and \| work with multivalued vectors, they return a vector whose length matches their input arguments.

-   Alternative way of negating a condition or set of conditions: `if (!(condition))`

    -   Makes it less readable IMO, but maybe for a complicated set of conditions if makes more sense in your head to do it this way

    -   [Example]{.ribbon-highlight}

        ``` r
        if (!(nr == nrow(iris) || (nr == nrow(iris) - 2))) {print("moose")}
        ```

-   Using `else if`

    ``` r
    if (condition1) {
      expr1
    } else if (condition2) {
      expr2
    } else {
      expr3
    }
    ```

-   `stopifnot`

    ``` r
    pred_fn <- function(steps_forward, newdata) {
      stopifnot(steps_forward >= 1)
      stopifnot(nrow(newdata) == 1)
      model_f = model_map[[steps_forward]]
      # apply the model to the last "before the test period" row to get
      # the k-steps_forward prediction
      as.numeric(predict(model_f, newdata = newdata))
    }
    ```

-   `%||%`

    -   Collapse operator which acts like:

        ``` r
        `%||%` <- function(x, y) {
           if (is_null(x)) y else x
        }
        ```

        -   Says if the first (left-hand) input `x` is `NULL`, return `y`. If `x` is not `NULL`, return the input

    -   Use Cases

        -   Determine whether a function argument is NULL

            ``` r
            github_remote <- 
              function(repo, username = NULL, ...) {
                meta <- parse_git_repo(repo)
                meta$username <- username %||%
                  getOption("github.user") %||%
                  stop("Unknown username")
              }
            ```

        -   Within the `print` argument [collapse]{.arg-text}

            ``` r
            library(rlang)

            add_commas <- function(x) {
              if (length(x) <= 1) {
                collapse_arg <- NULL
              } else {
                collapse_arg <- ", "
              }
              print(paste0(x, collapse = collapse_arg %||% ""))
            }

            add_commas(c("apples"))
            [1] "apples"
            add_commas(c("apples", "bananas"))
            [1] "apples, bananas"
            ```

## Loops {#sec-r-baser-loops .unnumbered}

-   Misc

    -   `next` - Proceeds to the next iteration of the loop
    -   `break` - Stops the loop

-   For

    -   If you have to use for-loops, you should pre-allocate memory first to increase performance

        ``` r
        # bad
        result <- c()
        result <- list()

        # good
        result <- numeric(10)  # Pre-allocate numeric vector
        for (i in 1:10) {
            result[i] <- i^2
        }

        result <- vector("list", n)  # Pre-allocate
        for (i in 1:n) 
          result[[i]] <- i^2
        ```

    -   [Example]{.ribbon-highlight}: List or vector ([source](https://www.spsanderson.com/steveondata/posts/2024-10-22/))

        ``` r
        numbers_list <- list(1, 2, 3, 4, 5)
        squared_numbers <- vector("list", length(numbers_list))

        for (i in seq_along(numbers_list)) {
          squared_numbers[[i]] <- numbers_list[[i]]^2
        }

        print(squared_numbers)
        ```

    -   [Example]{.ribbon-highlight}: Number Range and Nested

        ``` r
        # 2x3
        x <- matrix(1:6, 2, 3)

        for (i in seq_len(nrow(x))) {
          for(j in seq_len(ncol(x))) {
            print(x[i, j])
          }
        }
        ```

-   While

    -   [Example]{.ribbon-highlight} ([source](https://www.spsanderson.com/steveondata/posts/2024-10-22/))

        ``` r
        numbers_list <- list(2, 4, 6, 8, 10, 12, 14)
        index <- 1

        while (numbers_list[[index]] <= 10) {
          index <- index + 1
        }

        print(paste("The first number greater than 10 is:", numbers_list[[index]]))
        ```

-   `tapply`

    ``` r
    tapply(mtcars$mpg, 
           mtcars$cyl, 
           FUN = mean)

    #>         4        6        8 
    #>  26.66364 19.74286 15.10000
    ```

## Columns {#sec-r-baser-col .unnumbered}

-   Change the names of all columns

    ``` r
    colnames(df) <- c("good", "better")
    ```

-   Change the name of 1 column

    ``` r
    colnames(df)[1] <- "NOX_ID"
    ```

    -   Changes 1st column's name to [NOX_ID]{.var-text}

-   Sorting/Ordering

    -   Ascending:

        ``` r
        df[with(df, order(col2)), ]
        # or
        df[order(df$col2), ]
        # or
        sort_by(df, df$col2)
        ```

        -   [col2]{.var-text} is the column used to sort the [df]{.var-text} by

    -   Descending: `df[with(df, order(-col2)), ]`

    -   By Multiple Columns

        -   Sequentially: `sort_by(df, df$col1, df$col2, df$col3)`
            -   Says sort by [col1]{.var-text} then [col2]{.var-text} then [col3]{.var-text}
        -   Descending then Ascending: `df[with(df, order(-col2, id)), ]`

    -   Move the 3rd column of a matrix/df to the 1st column

        ``` r
        mat_new <- mat[, c(3, setdiff(seq_len(ncol(mat)), 3))]
        ```

-   Change position of columns

    ``` r
    # Reorder column by index manually
    df2 <- df[, c(5, 1, 4, 2, 3)]
    df3 <- df[, c(1, 5, 2:4)]
    # Reorder column by name manually
    new_order = c("emp_id","name","superior_emp_id","dept_id","dept_branch_id")
    df2 <- df[, new_order]
    ```

## Set Operations

-   Unique values in A that are not in B

    ``` r
    a <- c("thing", "object")
    b <- c("thing", "gift")

    unique(a[!(a %in% b)])
    #> [1] "object"

    setdiff(a, b)
    ```

    -   `setdiff` is slower

-   Unique values of the two vectors combined

    ``` r
    unique(c(a, b))
    #> [1] "thing"  "object" "gift"

    union(a, b)
    ```

    -   `union` is just a wrapper for `unique`

## Subsetting {#sec-r-baser-subset .unnumbered}

-   Lists and Vectors

    -   Removing Rows

        ``` r
        # Remove specific value from vector
        x[!x == 'A']

        # Remove multiple values by list
        x[!x %in% c('A', 'D', 'E')]

        # Using setdiff
        setdiff(x, c('A','D','E'))

        # Remove elements by index
        x[-c(1,2,5)]

        # Using which
        x[-which(x %in% c('D','E') )]

        # Remove elements by name
        x <- c(C1='A',C2='B',C3='C',C4='E',C5='G')
        x[!names(x) %in% c('C1','C2')]
        ```

-   Dataframes

    -   Remove specific Rows

        ``` r
        df <- df[-c(25, 3, 62), ]
        ```

    -   Remove column by name

        ``` r
        df <- df[, which(names(df) == "col_name")]
        df <- subset(df, select = -c(col_name))
        df <- df[, !names(df) %in% c("col1", "col2"), drop = FALSE]
        ```

    -   Filter and Select

        ``` r
        df <- 
          subset(df, 
                 subset = col1 > 56, 
                 select = c(col2, col3))
        ```

-   Value Replacement

    -   Replace NAs in one df with values from another df

        ``` r
        tib1$latitude[tib1$name == "Bob"] <- tib2[tib2$name == "Bob", "lat"]
        tib1$longitude[tib1$name == "Bob"] <- tib2[tib2$name == "Bob", "long"]
        ```

        -   Also see [R, Tidyverse \>\> dplyr](r-tidyverse.qmd#sec-r-tidy-dplyr){style="color: green"} \>\> `rows_update`
        -   [tib1]{.var-text} has NAs for Bob's [latitude]{.var-text} and [longitude]{.var-text}
        -   [tib2]{.var-text} has values in [lat]{.var-text} and [long]{.var-text} for Bob's latitude and longitude

## Transformation {#sec-r-baser-err-trans .unnumbered}

-   [Example]{.ribbon-highlight}: `transform` and `subset` ([source](https://bsky.app/profile/kearney.bsky.social/post/3lllpi6sifc2m))

    ``` r
    mtcars |> 
      transform(avg = mpg / wt) |> 
      subset(avg > 5) |> 
      subset(, c(wt, mpg, avg))
    ```

    -   `transform` cannot refer to variables previously created in the same transformation. You'd be required to use an additional transform in order to use that variable.

    -   See [Functions](r-base-r.qmd#sec-r-baser-funs){style="color: green"} \>\> `within` for an alternate method

## Joins {#sec-r-baser-err-join .unnumbered}

-   Inner join: `inner <- merge(flights, weather, by = mergeCols)`
-   Left (outer) join: `left  <- merge(flights, weather, by = mergeCols, all.x = TRUE)`
-   Right (outer) join: `right <- merge(flights, weather, by = mergeCols, all.y = TRUE)`
-   Full (outer) join: `full <- merge(flights, weather, by = mergeCols, all = TRUE)`
-   Cross Join (Cartesian product): `cross <- merge(flights, weather, by = NULL)`
-   Natural join: `natural <- merge(flights, weather)`

## Error Handling {#sec-r-baser-err .unnumbered}

-   `stop`

    -   [Example]{.ribbon-highlight}:

        ``` r
        switch(parallel,
               windows = "snow" -> para_proc,
               other = "multicore" -> para_proc,
               no = "no" -> para_proc,
               stop(sprintf("%s is not one of the 3 possible parallel argument values. See documentation.", parallel)))
        ```

        -   [parallel]{.arg-text} is the function argument. If it doesn't match one of the 3 values, then an error is thrown.

-   `try`

    -   If something errors, then do something else

    -   [Example]{.ribbon-highlight}

        ``` r
        current <- try(remDr$findElement(using = "xpath",
                                        '//*[contains(concat( " ", @class, " " ),
                                        concat( " ", "product-price-value", " " ))]'),
                                        silent = T)
        #If error : current price is NA
        if(class(current) =='try-error'){
            currentp[i] <- NA
        } else {
            # do stuff
        }
        ```

-   `tryCatch`

    -   Run the main code, but if it "catches" an error, then the secondary code (the workaround) will run.

    -   [Example 1]{.ribbon-highlight}: Basic

        ``` r
        tryCatch(
          # try to evaluate the expression
          {
            log("a")
          },

          # what happens if there's a warning?
          warning = function(w) {
            print("There was a warning. Here's the message:")
            print(w)
          },

          # what happens if there's an error?
          error = function(e) {
            print("There was an error. Returning `NA`.")
            return(NA)
          }
        )
        ```

    -   [Example 2]{.ribbon-highlight}: Logging 1

        ``` r
        err_pkgs <- list()

        for (i in seq_along(moose)) {
          print(moose[i])
          tryCatch(
            expr = pak::pkg_install(moose[i], ask = FALSE),
            error = function(e) {
              err_pkgs[[i]] <<- moose[i]
            }
          )
        }
        ```

        -   Stores the names of packages that don't get installed into [err_pkgs]{.var-text}
        -   Note the super-assignment used so that the error function can find [err_pkgs]{.var-text}
            -   Needed since [err_pkgs]{.var-text} is being *modified* and not just called

    -   [Example 3]{.ribbon-highlight}: Logging 2 ([source](https://github.com/joekirincic/burst-reporting/blob/2164be1289d897070905f4d33d8a3b24306e3da0/burst-report.R#L103C1-L197C2))

        ``` r
        OUTPUT_DIR <- "reports"

        # Create output directory
        if (!dir.exists(OUTPUT_DIR)) {
          dir.create(OUTPUT_DIR, recursive = TRUE)
          cat(sprintf("Created output directory: %s\n", OUTPUT_DIR))
        }

        # Initialize logging
        log_file <- file.path(
          OUTPUT_DIR,
          sprintf("burst-report-log_%s.txt", format(Sys.time(), "%Y%m%d_%H%M%S"))
        )
        log_conn <- file(log_file, open = "wt")

        log_msg <- function(msg, level = "INFO") {
          timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
          log_line <- sprintf("[%s] %s: %s", timestamp, level, msg)
          cat(log_line, "\n", file = log_conn)
          cat(log_line, "\n")
        }

        tryCatch(
          {
            # some code
          },
          error = function(e) {
            # Clean up temp directory on error
            if (dir.exists(temp_dir)) {
              unlink(temp_dir, recursive = TRUE)
            }

            error_msg <- sprintf(
              "Failed for store %d (%d-%02d): %s",
              store_key,
              year,
              month,
              e$message
            )
            log_msg(error_msg, "ERROR")
          }
        )
        ```

    -   [Example 4]{.ribbon-highlight}: Basic in a for-loop

        ``` r
        for (r in 1:nrow(res)) {
          cat(r, "\n")

          tmp_wikitext <- get_wikitext(res$film[r], res$year[r])

          # skip if get_wikitext fails
          if (is.na(tmp_wikitext)) next
          if (length(tmp_wikitext) == 0) next

          # give the text to openai
          tmp_chat <- tryCatch(
            get_results(client, tmp_wikitext),
            error = \(x) NA
          )

          # if openai returned a dict of 2
          if (length(tmp_chat) == 2) {
            res$writer[r] <- tmp_chat$writer
            res$producer[r] <- tmp_chat$producer
          }
        }
        ```

        -   `get_results` is called during each iteration, and if there's an error a [NA]{.arg-text} is returned.

    -   [Example 5]{.ribbon-highlight}

        ``` r
        pct_difference_error_handling <- function(n1, n2) {
        # Try the main code
          tryCatch(pct_diff <- (n1-n2)/n1,
                # If you find an error, use this code instead
                  error = return(
                    cat( 'The difference between', as.integer(n1), 'and', as.integer(n2), 'is',
                          (as.integer(n1)-as.integer(n2)), 'which is',
                          100*(as.integer(n1)-as.integer(n2))/as.integer(n1),
                          '% of', n1 )#cat
                    ),
                  # finally = print('Code ended') # optional
                  )#trycatch
          # If no error happens, return this statement
          return ( cat('The difference between', n1, 'and', n2, 'is', n1-n2,
                      ', which is', pct_diff*100, '% of', n1) )
        }
        ```

        -   Assumes the error will be the user enters a string instead of a numeric. If errors, converts string to numeric and calcs.
        -   "finally" - This argument will always run, regardless if the try block raises an error or not. So it could be a completion message or a summary, for example.

## Models {#sec-r-baser-mods .unnumbered}

-   `formula` and `update`

    ``` r
    form <- formula(log(median) ~ CRIM + ZN + INDUS + CHAS + 
                    I((NOX*10)^2) + I(RM^2) + AGE + log(DIS) +
                    log(RAD) + TAX + PTRATIO + I(BB/100) + 
                    log(I(LSTAT/100)))

    MLM <- lmer(update(form, . ~ . + (1 | NOX_ID)), 
                data = boston_487, REML = FALSE)
    ```

-   `reformulate` - Create formula sytax programmatically

    ``` r
    # Creating a formula using reformulate()
    formula <- reformulate(c("hp", "cyl"), response = "mpg")

    # Fitting a linear regression model
    model <- lm(formula, data = mtcars)

    formula
    ##> mpg ~ hp + cyl
    ```

    -   Can also use `as.formula`

-   `DF2formula` - Turns the column names from a data frame into a formula. The first column will become the outcome variable, and the rest will be used as predictors

    ``` r
    DF2formula(Orange)
    #> Tree ~ age + circumference
    ```

-   `formula` - Provides a way of extracting formulae which have been included in other objects

    ``` r
    rec_obj |> prep() |> formula()
    ```

    -   Where "rec_obj" is a tidymodels recipe object

-   Data from Model Object

    -   `model$model` return the data dataframe
    -   `deparse(model$call$data)` gives you that name of your data object as a string.
        -   `model$call$data` gives you the data as an unevaluated symbol;
    -   `eval(model$call$data)` gives you back the original data object, if it is available in the current environment.
