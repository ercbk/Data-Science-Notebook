# Quarto {#sec-quarto .unnumbered}

## Misc {#sec-quarto-misc .unnumbered}

-   Packages

    -   [{]{style="color: #990000"}[quarto](https://quarto-dev.github.io/quarto-r/){style="color: #990000"}[}]{style="color: #990000"}

-   Resources

    -   [Docs](https://quarto.org/docs/guide/)
    -   [Reference](https://quarto.org/docs/reference/)
    -   [Troubleshooting](https://quarto.org/docs/troubleshooting/index.html#out-of-memory-issues)

-   `quarto --version` - Must be in RStudio Terminal

-   `quarto check` - Must be in RStudio Terminal - versions and engine checks

    ``` bash
    $ quarto check
    [>] Checking versions of quarto binary dependencies...
          Pandoc version 3.1.1: OK
          Dart Sass version 1.55.0: OK
    [>] Checking versions of quarto dependencies......OK
    [>] Checking Quarto installation......OK
          Version: 1.3.340
          Path: C:\Users\tbats\AppData\Local\Programs\Quarto\bin
          CodePage: 1252
    [>] Checking basic markdown render....OK
    [>] Checking Python 3 installation....OK
          Version: 3.8.1 (Conda)
          Path: C:/Users/tbats/Miniconda3/python.exe
          Jupyter: 4.9.1
          Kernels: python3
    (\) Checking Jupyter engine render....2023-04-28 10:18:15,018 - traitlets - WARNING - Kernel
    Provisioning: The 'local-provisioner' is not found.  This is likely due to the presence of multiple jupyter_client distributions and a        previous distribution is being used as the source for entrypoints - which does not include 'local-provisioner'.  That distribution should     be removed such that only the version-appropriate distribution remains (version >= 7).  Until then, a 'local-provisioner' entrypoint will     be automatically constructed and used.
    The candidate distribution locations are: ['C:\\Users\\tbats\\Miniconda3\\lib\\site-packages\\jupyter_client-5.3.4.dist-info',                'C:\\Users\\tbats\\Miniconda3\\lib\\site-packages\\jupyter_client-7.0.6.dist-info']
    [>] Checking Jupyter engine render....OK
    [>] Checking R installation...........OK
          Version: 4.2.3
          Path: C:/PROGRA~1/R/R-42~1.3
          LibPaths:
            - C:/Users/tbats/AppData/Local/R/win-library/4.2
            - C:/Program Files/R/R-4.2.3/library
          knitr: 1.42
          rmarkdown: 2.20
    [>] Checking Knitr engine render......OK
    ```

-   CLI

    -   `quarto render` to compile a document
    -   `quarto preview` to render a live preview that automatically updates when the source files are saved

-   Using a development verison of Quarto

    -   First Usage
        -   Change directories to where you want to store the dev version

        -   Clone repo and change to the cloned directory

            ``` bash
            git clone https://github.com/quarto-dev/quarto-cli
            cd quarto-cli
            ```

        -   Disable Anti-Virus

        -   Run Configuration Script

            -   Windows Command Prompt

                ``` bash
                cmd /k configure.cmd
                ```

                -   `\k` keeps the window open in case it errors

            -   Powershell

                ``` powershell
                Invoke-Item configure.cmd
                ```

            -   Linux/MacOS

                ``` bash
                ./configure.sh
                ```

            -   This will take a minute or two as it checks versions, installs dependencies like pandoc, etc.

        -   Add path to quarto.cmd to PATH

            -   After the configuration file runs, it will output the path you need to put on PATH, e.g. `"C:\Users\erc\Documents\Quarto\quarto-cli\package\dist\bin"`

        -   Enable Anti-Virus

        -   Should be able to use in RStudio

            -   I was not able to use the RStudio terminal for quarto commands (e.g. `quarto check`) though.
            -   To find the version, I just opened powershell and ran `quarto –version` just to make sure it was running and on PATH.
                -   Not sure if they use this every time but it was 99.9.9 instead of the verion in the changelog.
            -   I also rendered a qmd file using `quarto-cmd` from the root directory of quarto-cli to see if it matched the output from RStudio. (`cd qmd` then `quarto preview forecasting-statistical.qmd --to html --no-watch-inputs --no-browse`)
    -   Subsequent Development Versions
        -   Change directory to quarto-cli and `git pull`

-   Shortcuts

    -   New R chunk: ctrl + alt + i
    -   Build whole book: ctrl+shift b
    -   Render page and preview book: ctrl+shift k

-   Using yaml style for chunk options\
    ![](./_resources/Quarto_RMarkdown.resources/FAiWv2DXMAEwZJH%20(2).jpg){.lightbox width="541"}

-   Convert Rmd chunk options to Quarto: `knitr::convert_chunk_header("doc.rmd", "doc.qmd")`

-   [**Anchor Link**]{style="color: #009499"} - A link, which allows the users to flow through a website page. It helps to scroll and skim-read easily. A named anchor can be used to link to a different part of the same page (like quickly navigating) or to a specific section of another page.

    -   This is the "#sec-moose" id that can be added to headers which it allows to be referenced within the document or in other documents.

-   MathJax commands

    -   Font Size: `\tiny{ }, \scriptsize{ }, \small{ }, \normal{ }, \large{ }, \Large{ }, \LARGE{ }, \huge{ }, \Huge{ }`

-   Lightbox

    -   [Docs](https://quarto.org/docs/output-formats/html-lightbox-figures.html)
    -   Grouping images for lightbox carousel: `![A Lovely Image](mv-1.jpg){group="my-gallery"}`

## Syntax {#sec-quarto-syntax .unnumbered}

-   Inline code

    ``` markdown
    -   Total number of counties: **`{{r}} polling_places |> filter(state == "Alabama") |> distinct(county_name) |> count()`**
    -   Total number of polling places: **`{{r}} polling_places |> filter(state == "Alabama") |> count()`**
    -   Election Day: **`{{r}} polling_places |> filter(state == "Alabama") |> pull(election_date) |> unique()`**
    ```

-   Align code chunk under bullet and add indented comment below chunk

    ```` markdown
    -   [Example]{.ribbon-highlight} (using a SQL Query; method 1)

        ``` r
        # open dataset
        ds <- arrow::open_dataset(dir_out, partitioning = "species")
        # open connection to DuckDB
        con <- dbConnect(duckdb::duckdb())
        # register the dataset as a DuckDB table, and give it a name
        duckdb::duckdb_register_arrow(con, "my_table", ds)
        # query
        dbGetQuery(con, "
          SELECT sepal_length, COUNT(*) AS n
          FROM my_table
          WHERE species = 'species=setosa'
          GROUP BY sepal_length
        ")

        # clean up
        duckdb_unregister(con, "my_table")
        dbDisconnect(con)
        ```

        -   filtering using a partition, the WHERE format is '\<partition_variable\>=\<partition_value\>'
    ````

    -   Space between bullet and top ticks
    -   Space between bottom ticks and bullet
    -   Note alignment of text

-   Add Code Annotations

    ```` markdown
    -   [Partition a large file and write to arrow format]{.underline}

        ``` r
        lrg_file <- open_dataset(<file_path>, format = "csv") # <1>
        lrg_file %>%
            group_by(var) %>% # <2>
            write_dataset(<output_dir>, format = "feather") # <3>
        ```

        1.  Pass the file path to `open_dataset()`

        2.  Use `group_by()` to partition the Dataset into manageable chunks

        3.  Use `write_dataset()` to write each chunk to a separate Parquet file---all without needing to read the full CSV file into R

        -   `open_dataset` is fast because it only reads the metadata of the file system to determine how it can construct queries
    ````

-   Footnote

    ``` markdown
    words [^1]

    [^1]: Data from https://github.com/rfordatascience/tidytuesday
    ```

-   For PDF output, you need pagebreaks:

    ``` markdown
    {{{< pagebreak >}}}
    ```

## YAML {#sec-quarto-yaml .unnumbered}

-   Set global chunk options in yaml\
    ![](./_resources/Quarto_RMarkdown.resources/image.png){.lightbox width="283"}

    -   For code cells

        ``` yaml
        execute:
          echo: false
          message: false
          warning: false
        ```

-   Enable Margin Notes

    ``` yaml
    ---
    # YAML front matter
    reference-location: margin
    ---
    ```

-   `!expr` to render code within chunk options

    -   e.g. figure caption: `#| fig-cap: !expr glue::glue("The mean temperature was {mean(airquality$Temp) |> round()}")`

-   `column: screen-inset` yaml markup is used to show a very wide table

-   If you haven't set your Quarto document to be `self-contained`, then the images have also already been saved for you - probably in a folder called `documentname_files/figure-html/`

    ``` yaml
    format: 
      html:
        embed-resources: true
    ```

-   Date first published and date modified using the current date:

    ``` yaml
    ---
    date: 2024-01-01
    date-modified: today
    ---
    ```

-   YAML Examples

    -   Example\
        ![](./_resources/Quarto_RMarkdown.resources/image.1.png){.lightbox width="334"}

## Chunk Options {#sec-quarto-chunk .unnumbered}

-   Graphics

    -   Code Chunk

        ``` markdown
        #| label: "fig-statemap"
        #| dpi: 300
        #| fig.height: 7.2
        #| fig.width: 3.6
        #| dev: "png"
        #| echo: false
        #| warning: false
        #| message: false
        ```

        -   Example shows settings for a graph for mobile
        -   `fig.height` and `fig.width` are always given in inches

    -   Reference Figure

        ``` markdown
        1 See polling place locations in @fig-statemap.
        ```

-   Conditional Code Chunk Evaluation

    -   [Example]{.ribbon-highlight}: document output type

        -   Set value in a code chunk

            ```` markdown
            ```{{r setup}}
            # Include in first chunk of .qmd
            # Get output file type
            out_type <- knitr::opts_knit$get("rmarkdown.pandoc.to")
            ```
            ````

        -   Use `!expr` sytax to determine evaluation status

            -   [Example]{.ribbon-highlight}: eval chunk based on output type

                ```` markdown
                ```{{r}}
                #| eval: !expr out_type == "html"
                    
                # code to create interactive {plotly}
                ```

                ```{{r}}
                #| eval: !expr out_type == "docx"
                    
                # code to create static {ggplot2}
                ```
                ````

    -   [Example]{.ribbon-highlight}: Use parameterization to set value

        ``` yaml
        ---
        title: "test"
        format: html
        params:
          my_value: false
        ---
        ```

        -   [my_value]{.var-text} can then be used throughout the document to determine chunk evaluation status

-   Knitr Hooks

    -   Notes from [Writing knitr hooks](https://blog.djnavarro.net/posts/2023-12-30_knitr-hooks/)
        -   Also has a knitr hook example that alters cell output (e.g. only prints 4 lines of a vector)
    -   Chunk Hooks
        -   Chunk hooks get called twice: once before knitr executes the code in the chunk, and once again afterwards

        -   The function can take up to four arguments, all of which are optional:

            -   [before]{.arg-text}: A logical value indicating whether the function is being called before or after the code chunk is executed
            -   [options]{.arg-text}: The list of chunk options
            -   [envir]{.arg-text}: The environment in which the code chunk is executed
            -   [name]{.arg-text}: The name of the code chunk option that triggered the hook function

        -   The chunk hook is called for its side effects not the return value. However, if it returns a character output, knitr will add that output to the document output as-is.

        -   [Example]{.ribbon-highlight}: Chunk Timer

            -   Code

                ``` r
                create_timer_hook <- function() {
                  start_time <- NULL
                  function(before, options) {
                    if (before) {
                      start_time <<- Sys.time()
                    } else {
                      stop_time <- Sys.time()
                      elapsed <- difftime(stop_time, start_time, units = "secs")
                      paste(
                        "<div style='font-size: 70%; text-align: right'>",
                        "Elapsed time:", 
                        round(elapsed, 2), 
                        "secs",
                        "</div>"
                      )
                    }
                  }
                }
                knitr::knit_hooks$set(timer = create_timer_hook())
                ```

                -   The hook is triggered the first time (with `before = TRUE`) to record the system time somewhere (e.g., in a variable called start_time). Then, when the hook is triggered the second time (with `before = FALSE`), it records the system time again (e.g., as stop_time), and computes the difference in time.

            -   Use in a cell

                ```` markdown
                ```{{r}}
                #| timer: true
                runif(10000)
                ```
                ````

            -   Output\
                ![](_resources/Quarto_RMarkdown.resources/chunk-hook-timer-out-1.png){.lightbox width="432"}

## R and Python {#sec-quarto-rpy .unnumbered}

-   If only R or R and Python, the notebook is rendered by [{knitr}]{style="color: #990000"}

-   If only Python, the notebook is rendered by jupyter

-   Set-up

    -   [{reticulate}]{style="color: #990000"} automatically comes loaded in Quarto and it knows to use it when it sees a python block, so you don't need to load the package
    -   Quarto will select a version of Python using the [Python Launcher](https://docs.python.org/3/using/windows.html#python-launcher-for-windows) on Windows or system `PATH` on MacOS and Linux. You can override the version of Python used by Quarto by setting the `QUARTO_PYTHON` environment variable.
        -   In CLI on Windows, type `py` is see which version the Python Launcher , and therefore Quarto, is using and `py –list` to see which versions are installed.

-   R

    ```` markdown
    ```{{r}}
    #| label: read-data
    #| echo: true
    #| message: false
    #| cache: true
    lemurs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-08-24/lemur_data.csv')
    ```
    ````

-   Python

    ```` markdown
    ```{{python}}
    #| label: modelling 
    #| echo: true 
    #| message: false

    lemur_data_py = r.lemur_data 
    import statsmodels.api as sm 
    y = lemur_data_py[["Weight"]] 
    x = lemur_data_py[["Age"]] 
    x = sm.add_constant(x) 
    mod = sm.OLS(y, x).fit() 
    lemur_data_py["Predicted"] = mod.predict(x) 
    lemur_data_py["Residuals"] = mod.resid`
    ```
    ````

    -   Use `r.` to access the data in the R chunk
    -   The first execution of a python cell starts `reticulate::repl_python()` in the terminal

-   (back to) R

    ```` markdown
    ```{{r}}
    #| label: plotting 
    #| echo: true 
    #| output-location: slide 
    #| message: false 
    #| fig-align: center 
    #| fig-alt: "Scatter plot of predicted and residual values for the fitted linear model." 

    library(reticulate) 
    library(ggplot2) 
    lemur_residuals <- py$lemur_data_py 
    ggplot(data = lemur_residuals, aes(x = Predicted, y = Residuals)) +
      geom_point(colour = "#2F4F4F") +
      geom_hline(yintercept = 0,
                colour = "red") +
      theme(panel.background = element_rect(fill = "#eaf2f2", colour = "#eaf2f2"),
            plot.background = element_rect(fill = "#eaf2f2", colour = "#eaf2f2"))
    ```
    ````

    -   Use `py$` to access the data in the Python chunk \*
    -   Must call `library(reticulate)` in order for Quarto to recognize `py$`

## Layouts {#sec-quarto-lay .unnumbered}

-   2 cols (1 col: text, 1 col: image)\
    ![](_resources/Quarto_RMarkdown.resources/quarto-2col-text-img.png){.lightbox width="554"}

    ``` markdown
    ::: {layout="[50,50]"}

    ::: column
    Every Quarto project starts with a Quarto file that has the extension `.qmd`.


    This particular one analyzes children's early words, but every `.qmd` includes the same three basic elements inside:


    - A block of metadata at the top, between two fences of `---`s. This is written in [YAML](https://learnxinyminutes.com/docs/yaml/). 
    - Narrative text, written in [Markdown](https://commonmark.org/help/tutorial/). 
    - Code chunks in gray between two fences of ```` ``` ````, written with R or another programming language.


    You can use all three elements to develop your code and ideas in one reproducible document.
    :::

    ![](img/01-source.png)
    :::
    ```

-   2 figures, 2 columns (i.e. side-by-side) with captions at the top

    ``` markdown
    ---
    fig-cap-location: top
    ---

    -   Words
        -   Predictions of Standard RF vs Oblique RF

            ::: {layout-ncol="2"}
            ![Standard Random Forest](_resources/Regression,_Survival.resources/ml-rf-obl-vs-axis-axpred-1.png){fig-align="left" width="432"}

            ![Oblique Random Forest](_resources/Regression,_Survival.resources/ml-rf-obl-vs-axis-oblpred-1.png){fig-align="left" width="432"}
            :::

            -   Words  
    ```

    -   [fig-cap-location: bottom]{.arg-text} is default;
    -   [fig-cap-location: margin]{.arg-text} is buggy, at least in for project type book. Captions are added to the margins but bullet points mysteriously disappear during rendering to html

-   2 charts side-by-side extending past body margins

    ```` markdown
    ```{{r}}
    #| label: my-figure
    #| layout-ncol: 2
    #| column: page
    ggplot() + ...
    ggplot() + ...
    ```
    ````

    -   "layout-ncol" says 2 side-by-side columns
    -   "column: page" says extend column width to the width of the page

-   Nested Tabs\
    ![](./_resources/Quarto_RMarkdown.resources/image.3.png){.lightbox width="511"}\
    ![](./_resources/Quarto_RMarkdown.resources/image.2.png){.lightbox width="391"}

## Automation {#sec-quarto-auto .unnumbered}

-   Iteration and Parameterization

    -   Notes from

        -   Velásquez R-Ladies Nairobi: [Code](https://github.com/ivelasq/reports-with-quarto-exercises/tree/main), [Slides](https://ivelasq.quarto.pub/getting-started-with-report-writing-using-quarto/#/title-slide), [Video](https://www.youtube.com/watch?v=Sf__ERCSgIA&ab_channel=R-LadiesNairobi)

    -   It involves having a “child” document as a template and running it repeatedly with different parameters

    -   The “main” document includes the output from the child document

    -   Rendering Options

        -   CLI: e.g. `quarto render polling-places-report.qmd -P state:'California'`

        -   [{quarto}]{style="color: #990000"}:

            ``` r
            quarto::quarto_render(
              input = here::here("polling-places-report.qmd"),
              execute_params = list(state = "California")
            )
            ```

    -   Example: Create a report for each parameter value. In each report, use the parameter value (e.g. state) to iterate through a template file that makes a tables (1 for each county) based on that value.

    -   Main Report Document

        ```` markdown
        ---
        title: "Polling Places Report - `r params$state`"
        params:
          state: "California"
        ---

        ```{{r}}
        #| results: hide

        library(dplyr)

        counties <- polling_places |> 
          filter(state == params$state) |> 
          distinct(county_name) |> 
          pull()

        expanded_child <- 
          counties |> 
            purrr::map(\(county) {
              knitr::knit_expand("../_template.qmd", 
                                 current_county = county))
              }|> 
            purrr::flatten()

        parsed_child <- knitr::knit_child(text = unlist(expanded_child))
        ```

        `{{r}} parsed_child`
        ````

        -   The document that gets published, emailed, etc.
        -   [params]{.arg-text} specified in YAML
            -   Value can also be used in the title of the document via inline R code
        -   Each [county]{.var-text} is iterated through the child document (\_template.qmd) via [current_county]{.arg-text} variable and `knit_expand`
        -   [parsed_child]{.var-text} is a list of the template file outputs.
        -   Then, [parsed_child]{.var-text} is converted to a character vector by `unlist` and *all* the results are printed in the document by the inline R code

    -   Child Document (i.e. Template)

        ```` markdown
        ### {{current_county}} COUNTY

        -   Total Polling Places: `{{r}} polling_places |> filter(state == params$state, county_name == "{{current_county}}") |> count()`
        -   Example Locations:

        ```{{r}}
        polling_places |> 
          filter(state == params$state, 
                 county_name == "{{current_county}}") |> 
          head(6) |> 
          select(name, address.x) |> 
          kbl(format = "markdown")
        ```
        ````

        -   Parameter value is used to get county data and create tables for each.
        -   No YAML is necessary in child document
            -   [params]{.arg-text} values are automatically available through `knitr::knit_expand` that's executed in the Main document
        -   The [county]{.var-text} variable is utilized by the template file using the double curly braces, `{{{current_county}}}`
        -   `kbl` outputs in markdown format so the table is correctly rendered in the Main document.

    -   Rendering Script

        ``` r
        polling_places <-
          readr::read_csv(here::here("data", "geocoded_polling_places.csv"))

        # create quarto::render arguments df
        polling_places_reports <-
          polling_places |>
          dplyr::distinct(state) |>
          dplyr::slice_head(n = 5) |>
          dplyr::mutate(
            output_format = "html",
            output_file = paste0(tolower(state),
                                 "-polling-places"),
            execute_params = purrr::map(state,
                                        \(state) list(state = state))
          ) |>
          # default output is html, so that variable not selected
          dplyr::select(output_file, execute_params) 

        # iterate through args and create reports
        purrr::pwalk(
          .l = polling_places_reports,
          .f = quarto::quarto_render,
          input = here::here("main_report_document.qmd"),
          .progress = TRUE
        )
        ```

        -   Creates a report for each [params]{.arg-text} value (e.g. [state]{.var-text})
        -   Generates a dataframe for each set of arguments to be fed to `quarto::quarto_render`.

## WebR {#sec-quarto-webr .unnumbered}

-   Set-Up

    -   Install the extension alongside your blog post by running `quarto add coatless/quarto-webr`
    -   Add the extension to your blog by adding `filters: ["webr"]` to your post’s frontmatter
    -   Instead of `{r}` code chunks, use `{webr-r}` ones

-   Install CRAN packages on page load

    ``` yaml
    filters:
      - "webr"
    webr:
      packages:
      - "dplyr"
      - "tidyr"
      - "purrr"
      - "tibble"
      - "crayon"
    ```

    -   Add to frontmatter

-   Install R-Universe Package

    ```` markdown
    ```{{webr-r}}
    #| context: setup
    webr::install("collateral", repos = c("https://jimjam-slam.r-universe.dev"))
    ```
    ````

    -   R-Universe packages must be installed in code cells
