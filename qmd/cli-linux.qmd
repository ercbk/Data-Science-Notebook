# Linux {#sec-cli-lin .unnumbered}

## Misc {#sec-cli-lin-misc .unnumbered}

-   Notes from

    -   [Bash for Data Scientists, Data Engineers & MLOps Engineers](https://towardsdatascience.com/bash-for-data-scientists-data-engineers-mlops-engineers-a8e389621e2e)
        -   Bunch of other stuff that I didn't take notes on
    -   [Bash Scripting on Linux: The Complete Guide](https://www.youtube.com/playlist?list=PLT98CRl2KxKGj-VKtApD8-zCqSaN2mD4w) - video course

-   Resources

    -   [Doc](https://docs.jade.fyi/gnu/bash/bash.html) - All on one page so you can just [ctrl + f]{.arg-text}
    -   Bash Scripting [Cheatsheet](https://devhints.io/bash)
    -   Curl [Docs](https://curl.se/docs/manpage.html)
    -   [Data Science at the Command Line: Obtain, Scrub, Explore, and Model Data with Unix Power Tools](https://jeroenjanssens.com/dsatcl/)
    -   [The Sudonomicon](https://lessonomicon.github.io/sudonomicon/)
    -   [Steve on Data's Linux articles](https://www.spsanderson.com/steveondata/index.html#category=linux)

-   Tools

    -   [bat](https://github.com/sharkdp/bat) - Modern `cat` function for pretty printing. Written in Rust.
        -   *Syntax Highlighting*: Bat provides syntax highlighting for a wide range of programming and markup languages.
        -   *Line Numbers*: It displays line numbers by default, helping users quickly locate and reference specific lines within a file.
        -   *Git Integration*: Bat can display Git modifications and file metadata directly in the output.
        -   *Customizable* Themes: Users can customize the color themes used for syntax highlighting to suit their preferences.
        -   *Automatic Paging*: Like the "cat" command, Bat can display the content of files, but it also includes automatic paging, allowing users to scroll through the content one screen at a time. You can navigate through the content using arrow keys, making it easier to read long files
    -   [Coreutils](https://uutils.github.io/coreutils/docs/) - Universal (as in cross-platform) CLI utilities in Rust (multi-threaded and parallelizable) (See benchmark [article](https://szarnyasg.org/posts/duckdb-vs-coreutils/) against DuckDB)
    -   [nano](https://www.nano-editor.org/) - text editor
    -   [rga](https://github.com/phiresky/ripgrep-all) - A line-oriented search tool that allows you to look for a regex in a multitude of file types: pdf, docx, sqlite, jpg, movie subtitles (mkv, mp4), etc
    -   [systemd](https://systemd.io/CREDENTIALS/) - A secure mechanism for handling sensitive data like cryptographic keys, API tokens, certificates, and passwords in modern Linux systems. (hrbrmstr [post](https://dailydrop.hrbrmstr.dev/2024/12/20/drop-580-2024-12-20-safety-first/), [Guide](https://hrbrmstrsdailydrop.wordpress.com/?action=user_content_redirect&uuid=1cbc8cfabe0eb4cfbf1777ff9f46a68bc27a8e9028dc041852cfb27def049bda&blog_id=227287867&post_id=139505825&user_id=261123797&subs_id=429064652&signature=aa34936a6121a0a44b21c77fc28c3266&email_name=new-post&user_email=nullspaceax0@gmail.com&encoded_url=aHR0cHM6Ly9mcmVlZGl1bS5jZmQvQHNlYmFzdGlhbmNhcmxvcy9zeXN0ZW1kcy1udXRzLWFuZC1ib2x0cy0wYWU3OTk1ZTQ1ZDM&email_id=fe26f9336085d38cd135e227ac0ab335), [Service Hardening](https://roguesecurity.dev/blog/systemd-hardening))

-   `man <command>` displays documentation for command

-   Special Characters\
    ![](./_resources/CLI.resources/image.1.png){.lightbox width="532"}

    -   "\>" redirects the output from a program to a file.
        -   "\>\>" does the same thing, but it's appending to an existing file instead of overwriting it, if it already exists.

-   Make a project directory and go to that directory

    ``` bash
    mkdir code/project
    cd $_
    ```

-   Get the dependency tree for a binary

    ``` bash
    ldd path/to/binary
    ```

-   `.bashrc` is a shell script that Bash runs whenever it is started interactively. It initializes an interactive shell session. You can put any command in that file that you could type at the command prompt.

    -   You put commands here to set up the shell for use in your particular environment, or to customize things to your preferences.
    -   A common thing to put in `.bashrc` are aliases that you want to always be available.

-   The `/opt` directory is a standard directory used for installing optional or add-on software packages. It's short for "optional" and is part of the Filesystem Hierarchy Standard (FHS).

-   Create symlinks

    -   Also see
        -   [Scripting](cli-linux.qmd#sec-cli-lin-script){style="color: green"} for bash script for creating symlinks example
        -   [CLI, Windows \>\> Powershell \>\> Misc](cli-windows.qmd#sec-cli-win-powsh-misc){style="color: green"} for other details on symlinks
    -   [Example]{.ribbon-highlight}: Personal R Environment for User1
        -   Create symlinks for R version and package directory

            ``` bash
            su - user1
            ln -s /opt/R/4.0.5/ ~/R-current

            mkdir -p ~/R-lib
            ln -s ~/R-lib ~/R-library

            ls -l ~/R-current
            ```

            -   A symlink called `R-current` in User1’s home directory, pointing to the R 4.0.5 installation.

            -   [-s]{.arg-text} stands for "symbolic" link

        -   Add symlinks to `.Renviron`

            -   Open `.Renviron`

                ``` bash
                nano ~/.Renviron
                ```

            -   Add symlinks to environment variables

                ```         
                R_HOME=~/R-current
                R_LIBS_USER=~/R-library
                ```

-   `passwd` is a text file that stores user account information on Unix/Linux systems. Each line represents one user, and fields are separated by colons

    -   Example: `john:x:1001:1001:John Doe:/home/john:/bin/bash`

        | Field | Meaning              | Value        |
        |-------|----------------------|--------------|
        | 1     | Username             | `john`       |
        | 2     | Password placeholder | `x`          |
        | 3     | User ID (UID)        | `1001`       |
        | 4     | Group ID (GID)       | `1001`       |
        | 5     | Full name or comment | `John Doe`   |
        | 6     | Home directory       | `/home/john` |
        | 7     | Shell                | `/bin/bash`  |

-   Debian vs. Ubuntu

    -   Stability vs. Freshness:

        -   Debian: Debian is known for its stability and reliability. It has a rigorous testing process and a conservative approach to updates, which makes it suitable for servers and systems where stability is crucial.
            -   New versions released approximately every 2-3 years
            -   Receives regular security and maintenance updates but not feature updates.
        -   Ubuntu: Ubuntu is based on Debian but tends to be more up-to-date with software packages.
            -   New versions released every six months (April and October). Every two years, an LTS (Long-Term Support) version is released, which is supported for five years.
            -   Regular (non-LTS) releases receive updates for nine months, while LTS releases receive security and maintenance updates for five years

    -   Package Management:

        -   Debian: Debian uses the Debian Package Management System (dpkg) and Advanced Package Tool (APT) for package management. It has a vast repository of software packages.
            -   Categorized into main, contrib, and non-free, with strict adherence to free software principles in the main repo
        -   Ubuntu: Ubuntu also uses dpkg and APT but adds its own software management tools like Snap and Ubuntu Software Center. This can make software installation more user-friendly.
            -   Categorized into main, universe, restricted, and multiverse, allowing more flexibility with proprietary and non-free software.

    -   Community and Support:

        -   Debian:
            -   Community: It's community-driven, so support may be slower and more focused on experienced users.
            -   Support: Primarily community-based through forums, mailing lists, and IRC channels
        -   Ubuntu:
            -   Community: A vibrant community and benefits from Canonical’s commercial backing, which provides professional support options.
            -   Support: In addition to community support, Ubuntu offers commercial support through Canonical, making it attractive for businesses.

    -   Licensing:

        -   Debian:
            -   If you are committed to using entirely free and open-source software, Debian is the better choice. Debian’s strict licensing policy ensures that the software in its main repository adheres to the highest standards of software freedom.
            -   Users who need non-free software must enable the **"**contrib**"** or **"**non-free**"** repositories manually, making it clear when non-free software is being used.
        -   Ubuntu: While Ubuntu also includes mostly free and open-source software, it may include some proprietary drivers and software by default, which can be a concern for users who prioritize a completely open-source system

    -   Performance

        -   Debian
            -   Server Performance: Debian is often preferred for servers due to its stability, minimal resource usage, and flexibility. It can be tuned for performance with fewer running services, making it ideal for high-performance server applications
            -   Lightweight Desktops: Debian can be configured to run very efficiently on desktops, especially with lightweight environments or minimal installations.
        -   Ubuntu
            -   General Desktop Use: Ubuntu is optimized for a good balance of performance and user experience. It’s a solid choice for general desktop use, especially on modern hardware.
            -   Cloud and Container Performance: Ubuntu is widely used in cloud and container environments (e.g., Ubuntu Server, Ubuntu Core), where its performance is optimized for these specific use cases

    -   Hardware

        -   Debian works well on older hardware. Debian still offers a 32-bit version of the distro, while Ubuntu no longer offers a 32-bit version.

## Commands {#sec-cli-lin-com .unnumbered}

### Basic Commands {#sec-cli-lin-com-bas .unnumbered}

![](./_resources/CLI.resources/image.png){.lightbox width="532"}

-   `echo $SHELL` - prints the type of shell you're using
-   `echo $PATH` - prints all stored pathes
-   `export PATH="my_new_path:$PATH"` - store a new path
-   Command Syntax: `command -options arguments`
-   Piping Commands: `cat user_names.txt|sort|uniq`
-   `du` - Disk Usage; Useful for getting the size of directories ([link](https://www.redhat.com/sysadmin/du-command-options))
    -   Flags

        -   [-h]{.arg-text} - Human readable output (i.e. instead of bytes, you get kilobytes, megabytes, etc.)
        -   [-s]{.arg-text} - Summarize; size of a particular directory in bytes
        -   [-a]{.arg-text} - All files including directories
        -   [-c]{.arg-text} - Calculates the total size of the printed output
        -   [-d]{.arg-text} - Specify how levels deep into a directory you want stats for (e.g. [-d 2]{.arg-text})
        -   [--time]{.arg-text} - Time of last modification

    -   [Example]{.ribbon-highlight}: Sort directories by size

        ``` bash
        du -sh /* | sort -h
        ```

    -   [Example]{.ribbon-highlight}: Calculate size of directory

        ``` bash
        du -c -h /home/my/directory
        ```

### Aliases {#sec-cli-lin-com-ali .unnumbered}

-   Custom commands that you can define in order to avoid typing lengthy commands over and over again

-   [Examples]{.ribbon-highlight}

    ``` bash
    alias ll="ls -lah"
    alias gs="git status"
    alias gp="git push origin master"
    ```

-   Create safeguards for yourself

    ``` bash
    alias mv="mv -i"
    ```

    -   `mv` will automatically use the [i]{.arg-text} flag, so the terminal will warn you if the file you're about to move does already exist under the new directory,
        -   This way you don't accidentally overwrite files that you didn't mean to overwrite.

### Files/Directories {#sec-cli-lin-com-file .unnumbered}

-   List\
    ![](./_resources/CLI.resources/image.2.png){.lightbox width="532"}

    -   List 10 most recently modified files: `ls -lt | head`
    -   List files sorted by file size: `ls -l -S`
    -   List multiple directories: `ls ./docs ./text ./data`

-   List open files

    -   List processes accessing a certain file

        ``` bash
        lsof <path_to_file>
        ```

    -   List all open files in a directory

        ``` bash
        lsof +D <path_to_directory>
        ```

    -   List files opened by pid(s)

        ``` bash
        lsof -p pid1
        lsof -p pid1, pid2, pid3
        ```

    -   List files opened by a command

        ``` bash
        lsof -c <command>
        ```

        -   e.g. files opened by a http daemon, you just need to specify the command `httpd`.

-   Count the lines of a file: `wc -l file.csv`

-   Look at first 3 rows: `head -n3 students.csv`

-   Create/Delete Directories

    ``` bash
    mkdir <dir_name>
    rmdir <dir_name>
    ```

    -   [-v]{.arg-text} means "verbose" so it tells us if it was successful

-   Output to file: `echo “This is an example for redirect” > file1.txt`

-   Append line to file: `echo “This is the second line of the file” >> file1.txt`

-   Create/Delete file(s):

    ``` bash
    # Create files
    touch file1.txt
    touch file1.txt file2.tx

    # Delete files
    rm file1.txt
    rm file1.txt file2.txt
    rm -rf mydir
    ```

    -   [-r]{.arg-text} (recursive):
        -   Removes directories and their contents
        -   Without -r, rm can only delete files, not directories
        -   Goes through subdirectories and deletes everything inside
    -   [-f]{.arg-text} (force):
        -   Suppresses confirmation prompts Doesn't ask "are you sure?" for each file Ignores "file not found" errors (won't complain if the file/directory doesn't exist) Overrides file permissions (removes read-only files without asking)

-   Move files/dir; Rename

    ``` bash
    # Move single file
    mv my_file.txt /tmp
    # Move multiple files
    mv file1 file2 file3 /tmp
    # move only .csv files to data directory and be verbose
    mv -v *.csv ./data/
    # Move a directory or multiple directories
    mv d1 d2 d3 /tmp
    # Rename the file using move command
    mv my_file1.txt my_file_newname.txt
    ```

    -   File(s) and directories being moved to "tmp" directory

-   Search

    -   Find

        ``` bash
        # syntax find <path> <expression>
        # Find by name
        find . -name “my_file.csv"
        #Wildcard search
        find . -name "*.jpg"
        # Find all the files in a folder
        find /temp
        # Search only files
        find /temp -type f
        # Search only directories
        find /temp -type d
        # Find file modified in last 3 hours
        find . -mmin -180
        # Find files modified in last 2 days
        find . -mtime -2
        # Find files not modified in last 2 days
        find . -mtime +2
        # Find the file by size
        find -type f -size +10M
        ```

    -   Search inside files

        -   `zgrep` - Search the compressed file or files content just providing the search term.

            -   Default: Prints the matched file name and the complete line

            -   Flags

                -   [-i]{.arg-text}: Ignore case
                -   [-n]{.arg-text}: Print only matched lines
                -   [-v]{.arg-text}: Print only unmatched lines (i.e. *not* pattern)
                -   [-o]{.arg-text}: Print only the matched part
                -   [-l]{.arg-text}: Print only file names
                -   [-h]{.arg-text}: Print only file lines
                -   [-c]{.arg-text}: Count matched lines
                -   [-e]{.arg-text}: Multiple search terms

            -   [Example]{.ribbon-highlight}: Search multiple files

                ``` bash
                zgrep ismail auth.log.*.gz
                ```

                -   Searches for the term "ismail" all files beginning with "auth.log." in their names.
                -   \*Could also provide each file's name separated by a space\*

            -   [Example]{.ribbon-highlight}: Search for multiple terms

                ``` bash
                zgrep -e "ismail" -e "ahmet" auth.log.2.gz
                ```

        -   Seach a project directory for a line of code

            ``` bash
            rg -t python "def main" . | fzf
            ```

            -   [ripgrep](https://github.com/BurntSushi/ripgrep) (rg)
            -   [fzf install](https://www.ssp.sh/brain/recursive-search-in-terminal-with-fzf/), [article](https://towardsdatascience.com/turbocharge-your-command-line-game-3344b16bfeec)

-   Locate (faster)

    -   [Docs](https://linuxize.com/post/locate-command-in-linux/)

    -   Install

        `bash sudo apt install mlocate # Debian`

    -   Usage

        ``` bash
        sudo updatedb # update before using
        locate .csv
        ```

-   Unzip: `unzip ./foia.zip`

-   Split files

    ``` bash
    # default: 1000 lines per file, names of new files: xaa, xab, xac, etc.
    split my_file

    # add a prefix to new file names
    split my_file my_prefix

    # specify split threshold (e.g. 5000) by number of lines
    split --lines=5000 my_file

    # specify split threshold by size (e.g. 10MB)
    split --bytes=10 MB my_file
    ```

### Permissions {#sec-cli-lin-com-perm .unnumbered}

-   Notes from [Linux Permissions Explained: A Beginner’s Guide to File Security Command](https://www.spsanderson.com/steveondata/posts/2024-11-01/)

    -   Also see [FAQ](https://www.spsanderson.com/steveondata/posts/2024-11-01/#faqs)

-   Definitions

    -   User (u): The file’s owner
    -   Group (g): Members of the file’s assigned group
        -   Check users and groups: `id`
    -   Others (o): Everyone else on the system

-   Levels

    -   Read (r): Value of 4
    -   Write (w): Value of 2
    -   Execute (x): Value of 1

-   Notation: The [-]{.arg-text} seems to be a placeholder

    -   7 (rwx) = 4 + 2 + 1
    -   6 (rw-) = 4 + 2
    -   5 (r-x) = 4 + 1
    -   4 (r–) = 4

-   [Examples]{.ribbon-highlight}

    ``` bash
    # Symbolic mode
    chmod u+x script.sh    # Add execute permission for user
    chmod g-w file.txt     # Remove write permission for group
    chmod o=r document.pdf # Set others to read-only

    # Numeric mode
    chmod 755 script.sh    # rwxr-xr-x
    chmod 644 file.txt     # rw-r--r--

    # Standard web directory permissions
    chmod 755 /var/www/html
    chmod 644 /var/www/html/*.html

    # Create a shared directory
    mkdir /shared
    chmod 775 /shared
    chown :developers /shared

    # Make script executable
    chmod +x script.sh
    ```

    -   `chmod` - edit permissions
    -   `-rwxrwxrwx` - sytax of permissions for a folder or directory
        -   "rwx" stand for read, write, and execute rights, respectively
        -   The 3 "rwx" blocks are for (1) user, (2) user group, and (3) everyone else.
            -   In the given example, all 3 of these entities have read, write, as well as execute permissions.
        -   The dash indicates that this is a file. Instead of the dash, you can also see a "d" for directory or "l" for a symbolic link.

-   `ls -l problematic-file.txt` See list of files and the permissions

-   `sudo` - "super user" - using this prefix gives you all the permissions to all the files

    -   `sudo su` - opens a stand alone super user shell

    -   [Examples]{.ribbon-highlight}

        ``` bash
        # Switch to root user
        su -

        # Execute single command as root
        sudo apt update

        # Edit system file with sudo
        sudo nano /etc/hosts
        ```

-   `chown` - Change ownership

    -   [Examples]{.ribbon-highlight}

        ``` bash
        # Change owner
        chown user1 file.txt

        # Change owner and group
        chown user1:group1 file.txt

        # Recursive ownership change
        chown -R user1:group1 directory/
        ```

-   `unmask` - sets default permissions for new files and directories

    ``` bash
    # Check current umask
    umask

    # Set new umask
    umask 022  # Results in 755 for directories, 644 for files
    ```

### Print {#sec-cli-lin-com-print .unnumbered}

-   Print file content

    ``` bash
    cat < my_file.txt
    # or
    cat my_file.txt
    ```

-   Print 1 pg at a time: `less my_file.txt`

-   Print specific number of lines: `head -n<num_lines> <file.csv>`

-   Print file content from bottom to top: `tac my_file.txt`

-   `cat -b log.txt | grep error` : shows all lines in log.txt that contain the string 'error', along with the line number (-b)

### Logicals and Conditionals {#sec-cli-lin-com-logcond .unnumbered}

-   [Logicals]{.underline}
    -   [;]{.arg-text} : `command1 ; command2`

        -   command 1 and command 2 run independently of each other

    -   [&]{.arg-text} : `command1 & command2`

        -   command 1 runs in the background and command 2 runs in the background

    -   [&&]{.arg-text} : `command1 && command2`

        -   If the first command errors out then the second command is not executed

    -   [\|\|]{.arg-text} : `command1 || command2`

        -   The second commmand is only execute if the first command errors

    -   [Example]{.ribbon-highlight}

        ``` bash
        cd my_dir && pwd || echo “No such directory exist.Check”
        ```

        -   If the my_dir exists, then the current working directory is printed. If the my_dir doesn't exist, then the message "No such directory exists. check" message is printed.
-   [Conditionals]{.underline}
    -   Use `[[ ]]` for conditions in `if` / `while` statements, instead of `[ ]` or `test`.
        -   `[[ ]]` is a bash builtin, and is more powerful than `[ ]` or `test`.
        -   Example: `if [[ -n "${TRACE-}" ]]; then set -o xtrace; fi`

### String Matching {#sec-cli-lin-com-stri .unnumbered}

-   [Example]{.ribbon-highlight}: Search for "error" and write to file

    ``` bash
    #output to a file again
    cat file1 file2 file3 | grep error | cat > error_file.txt
    #Append to the end
    cat file1 file2 file3 | grep error | cat >> error_file.txt
    ```

    -   Prints lines into grep which searches for "error" in each line. Lines with "error" get written to "error_file.txt"

-   Filter lines

    ``` bash
    grep -i “Doctorate” adult_t.csv |grep -i “Husband”|grep -i “Black”|csvlook
    # -i, --ignore-case-Ignore  case  distinctions,  so that characters that differ only in case match each other.
    ```

    -   Select all the candidates who have doctorates and a husband and race are Black
    -   `csvlook` is pretty printing from csvkit package (see [Big Data \>\> Larger Than Memory](big-data.html#sec-bgdat-lgmem){style="color: green"} \>\> csvkit)

-   Count how many rows fit the criteria

    ``` bash
    grep -i “Doctorate” adult_t.csv | wc -l
    ```

    -   Counts how many rows have "Doctorate"
        -   [-wc]{.arg-text} is "word count"

### Input/Output

-   Standard FIle Descriptors

    | FD     | Name      | Description                    | Typical Default |
    |:-------|:----------|:-------------------------------|:----------------|
    | **0**  | `stdin`   | Standard input (keyboard/pipe) | `/dev/tty`      |
    | **1**  | `stdout`  | Standard output (screen)       | `/dev/tty`      |
    | **2**  | `stderr`  | Standard error (screen)        | `/dev/tty`      |

    -   `/dev/tty` is a special device file that represents the current terminal for a process
        -   It's a synonym for the controlling terminal of the current process
        -   Every process has a controlling terminal (if it was started from a terminal)
        -   `tty` stands for Teletype — a historical term for terminal devices.

-   Output Redirections

    ``` bash
    # to files
    command 1> file.txt    # Redirect stdout to a file named "file.txt"
    command 2> errors.log  # Redirect stderr to a file named "errors.log"

    # to file descriptors
    command 1>&2    # Redirect stdout to wherever stderr is currently going
    command 2>&1    # Redirect stderr to wherever stdout is currently going
    command >&2     # Same as 1>&2 (stdout implied when no number before >)
    ```

    -   Without `&` refers to a filename
    -   With `&` refers to a File Descriptor

-   Creating and Using Non-Standard File Descriptors

    ``` bash
    # create fd
    exec 3> output.log   # Open FD 3 for writing to output.log
    echo "test" >&3     # Write to FD 3
    exec 3>&-           # Close FD 3

    # reading from additional FDs
    exec 4< input.txt   # Open FD 4 for reading from input.txt
    read line <&4       # Read from FD 4
    exec 4<&-           # Close FD 4

    # appending with FDs
    command >> file           # Append stdout
    command 2>> error.log     # Append stderr
    command &>> both.log      # Append both (bash)
    ```

## Variables {#sec-cli-lin-var .unnumbered}

-   Misc

    -   [autoenv](https://github.com/hyperupcall/autoenv) - If a directory contains an `.env` file, it will automatically be executed when you `cd` into it
        -   [Using it with rig](https://github.com/r-lib/rig/issues/171#issuecomment-2115134109)

-   Local Variable:

    -   Declared at the command prompt
    -   Use lower case for name
    -   Available only in the current shell
    -   Not accessible by child processes or programs
    -   All user-defined variables are local variables

-   Environment (global) variables:

    -   Create with `export` command
    -   Use upper case for name
    -   Available to child processes

-   Declare local and environment variables then access via "\$"

    ``` bash
    # local
    ev_car=’Tesla’
    echo 'The ev car I like is' $ev_car

    # environment
    export EV_CAR=’Tesla’
    echo 'The ev car I like is' $EV_CAR
    ```

    -   No spaces in variable assignment

-   Calling variables

    -   `${var}` or `$var` vs `${var?}`

        ``` bash
        mv file1 file2 $subdir # oops, I overwrote file2
        mv file1 file2 ${subdir?} # error message instead of disaster
        ```

        -   Using `${var?}` throws an error when `var` has not been defined

-   Always quote variable accesses with double-quotes.

    -   One place where it's *okay* not to is on the *left-hand-side* of an `[[ ]]` condition. But even there I'd recommend quoting.
    -   When you need the unquoted behaviour, using bash arrays will likely serve you much better.

-   Functions

    -   Use local variables in functions.
    -   Accept multiple ways that users can ask for help and respond in kind.
        -   Check if the first arg is [-h]{.arg-text} or [--help]{.arg-text} or `help` or just `h` or even [-help]{.arg-text}, and in all these cases, print help text and exit.
    -   When printing error messages, please redirect to stderr.
        -   Use `echo 'Something unexpected happened' >&2` for this

## Functions {#sec-cli-lin-fun .unnumbered}

-   Basic

    ``` bash
    say_hello() {
      echo "hello"
    }
    say_hello
    ```

-   Using Return

    ``` bash
    failing_func () {
      return 1
    }
    ```

    -   `return` cannot take strings — only numbers 1 to 255

-   With arguments

    ``` bash
    say_hello() {
      echo "Hello $1 and $2"
    }
    say_hello "Ahmed" "Layla"
    ```

-   Declaring local and global variables

    ``` bash
    say_hello() {
      local x
      x=$(date)
      y=$(date)
    }
    ```

    -   `local` is a keyword
    -   [x]{.arg-text} is local and [y]{.arg-text} is global

-   Suppress errors

    ``` bash
    local x=$(moose)
    ```

    -   When `local` is used in the same line as the variable declaration, then the variable never errors. e.g. Even if [moose]{.arg-text} doesn't exist, this line won't trigger an error

## Loops

-   For\
    ![](_resources/Git,_general.resources/for-loops-1.png){.lightbox width="682"}
    -   Misc

        -   Notes from [Flow Control in Linux: Mastering For Loops for Beginners](https://www.spsanderson.com/steveondata/posts/2025-04-25/)

        -   Always quote variables to avoid word splitting and issues with spaces,

            -   e.g. `for i in “$var”` or `cat "$file"`

    -   Flavors

        -   Traditional Shell Form - Used mainly for iterating through lists of items

        -   C Language Form - Used mainly for numeric sequences

            -   Syntax

                ``` bash
                for ((expression1; expression2; expression3)); do
                    commands
                done
                ```

                -   `expression1`: Initialization (executed before the loop starts)

                -   `expression2`: Condition (checked before each iteration)

                -   `expression3`: Modification (executed after each iteration)

    -   Syntax Comparison

        | Type | Syntax | Example | Use Case |
        |------------------|------------------|------------------|------------------|
        | Traditional | for var in list | for i in A B C; do echo \$i; done | List iteration |
        | C-style | for ((expr;expr;expr)) | for ((i=0;i\<5;i++)); do echo \$i; done | Counter loops |
        | Range | for var in {x..y} | for i in {1..5}; do echo \$i; done | Sequences |
        | Command | for var in \$(cmd) | for i in \$(ls); do echo \$i; done | Command output |

    -   Traditional: Basic Examples

        ``` bash
        #!/bin/bash
        for i in A B C D; do 
            echo $i
        done
        #> A
        #> B
        #> C
        #> D

        for i in {1..5}; do
            echo "Number $i"
        done
        #> Number 1
        #> Number 2
        #> Number 3
        #> Number 4
        #> Number 5

        for file in *.txt; do
            echo "Processing $file"
        done

        #> Processing read_integer.txt
        #> Processing test_file.txt
        ```

    -   C-Style: Basic Examples

        ``` bash
        #!/bin/bash
        for ((i=0; i<5; i++)); do
            echo "Index $i"
        done
        #> Index 0
        #> Index 1
        #> Index 2
        #> Index 3
        #> Index 4
        ```

    -   Command Substitution Method

        ``` bash
        #!/bin/bash
        for user in $(cat /etc/passwd | cut -d: -f1); do
            echo "User: $user"
        done
        ```

        -   Iterates through the list of usernames from the `/etc/passwd` file. The `$(command)` command substitution syntax executes the command and returns its output as a list.
            -   Example on line in the file: `john:x:1001:1001:John Doe:/home/john:/bin/bash`
        -   The pipe (`|`) and `cut` process the file line by line
        -   [-d:]{.arg-text} says the *delimiter* is a colon
        -   [-f1]{.arg-text} says extract the first *field*

    -   Nested Loops

        ``` bash
        #!/bin/bash
        for i in {1..3}; do
            for j in {1..3}; do
                echo "Position $i,$j"
            done
        done

        #> Position 1,1
        #> Position 1,2
        #> Position 1,3
        #> Position 2,1
        #> Position 2,2
        #> Position 2,3
        #> Position 3,1
        #> Position 3,2
        #> Position 3,3
        ```

    -   Error-Checking

        ``` bash
        for file in *.txt; do
            if [ -f "$file" ]; then
                echo "Processing $file"
            else
                echo "Error: $file is not a regular file"
            fi
        done
        ```

    -   Snippets

        -   Create Multiple Directories

            ``` bash
            #!/bin/bash
            for name in project1 project2 project3; do
                mkdir -p "$name"
                echo "Created directory: $name"
            done
            ```

        -   Create Multiple Files

            ``` bash
            #!/bin/bash

            # Create a directory for the output files
            mkdir output

            # Loop through numbers 0 to 9 and create empty files
            for i in {0..9}; do
                touch "output/sample_${i:0:3}.txt"
            done

            echo "Files created in the output directory."
            ```

            -   The [\${i:0:3}]{.arg-text} syntax ensures that the number [i]{.arg-text} is padded with leading zeros to a width of 3 digits.

            -   Files that get created

                ```         
                output/sample_000.txt
                output/sample_001.txt
                output/sample_002.txt
                ...
                ```

        -   Rename FIles

            ``` bash
            #!/bin/bash
            count=1
            for file in *.jpg; do
                mv "$file" "image_$count.jpg"
                ((count++))
            done

            #> image_1.jpg
            #> image_2.jpg
            #> image_3.jpg
            ```

## Scripting {#sec-cli-lin-script .unnumbered}

-   Use the .sh (or .bash) extension for your script

-   Use long options, where possible (like [--silent]{.arg-text} instead of [-s]{.arg-text}). These serve to document your commands explicitly.

-   If appropriate, change to the script's directory close to the start of the script.

    -   And it's usually always appropriate.
    -   Use `cd "$(dirname "$0")"`, which works in *most* cases.

-   Use `shellcheck` — analysis too for shell scripts. Heed its warnings. ([link](https://github.com/koalaman/shellcheck))

-   Shebang line

    -   Contains the absolute path of the bash interpreter
        -   List paths to all shells: `cat/etc/shells`
    -   Use as the first line even if you don't give executable permission to the script file.
    -   Starts with "#!" the states the path of the interpreter
    -   Example: `#!/bin/bash`
        -   Interpreter installed in directory "/bin"
    -   Example: `#!/usr/bin/env bash`

-   Commands that should start your script\
    ![](_resources/CLI-Linux.resources/scripting-errors-1.jpeg){.lightbox width="532"}

    -   Use `set -o errexit`
        -   So that when a command fails, bash exits instead of continuing with the rest of the script.
    -   Use `set -o nounset`
        -   This will make the script fail, when accessing an unset variable. Saves from horrible unintended consequences, with typos in variable names.
        -   When you want to access a variable that may or may not have been set, use `"${VARNAME-}"` instead of `"$VARNAME"`, and you're good.
    -   Use `set -o pipefail`
        -   This will ensure that a pipeline command is treated as failed, even if one command in the pipeline fails.
    -   Use `set -o xtrace`, with a check on `$TRACE` env variable.
        -   For copy-paste: `if [[ -n "${TRACE-}" ]]; then set -o xtrace; fi`.
        -   This helps in debugging your scripts, a lot.
        -   People can now enable debug mode, by running your script as `TRACE=1 ./script.sh` instead of `./script.sh` .

-   [Example]{.ribbon-highlight}: Basic Execution a Bash Script

    -   Create a directory bash_script: `mkdir bash_script`

    -   Create a hello_world.sh file: `touch hello_script.sh`

    -   Open hello_script.sh (text editor?)

    -   Add code, save, and close

        ```         
        #!/bin/bash
        echo ‘Hello World’
        ```

    -   Make file executable: `chmod +x hello_world.sh`

    -   Execute file: `./hello_world.sh`

-   [Example]{.ribbon-highlight}: Create symlinks for mulitple accounts

    ``` bash
    #!/bin/bash
    for user in user1 user2 user3; do
        sudo -u $user ln -s /opt/R/4.0.5/ /home/$user/R-current
        sudo -u $user mkdir -p /home/$user/R-lib
        sudo -u $user ln -s /home/$user/R-lib /home/$user/R-library
        echo -e "R_HOME=/home/$user/R-current\nR_LIBS_USER=/home/$user/R-library" | sudo tee -a /home/$user/.Renviron
    done
    ```

    -   Also see [Misc \>\> Create Symlinks](cli-linux.qmd#sec-cli-lin-misc){style="color: green"}

-   [Example]{.ribbon-highlight}: Reporting Disk Space in Home Directories ([source](https://www.spsanderson.com/steveondata/posts/2025-04-25/#example-reporting-disk-space-in-home-directories))

    ``` bash
    #!/bin/bash
    # report_home_space: Reports disk space usage for home directories

    # Define the table format using printf notation
    format="%8s%10s%10s\n"

    # Set the directory list and user name based on privileges
    if [[ $(id -u) -eq 0 ]]; then
        dir_list="/home/*"
        user_name="All Users"
    else
        dir_list="$HOME"
        user_name="$USER"
    fi

    echo "<H2>Home Space Utilization for $user_name</H2>"

    # Loop through each directory in the list
    for dir in $dir_list; do
        total_files=$(find "$dir" -type f 2>/dev/null | wc -l)
        total_dirs=$(find "$dir" -type d 2>/dev/null | wc -l)
        total_size=$(du -sh "$dir" 2>/dev/null | cut -f1)

        echo "<H3>$dir</H3>"
        echo "<PRE>"
        printf "$format" "Dirs" "Files" "Size"
        printf "$format" "----" "-----" "----"
        printf "$format" "$total_dirs" "$total_files" "$total_size"
        echo "</PRE>"
    done

    #> <H2>Home Space Utilization for steve</H2>
    #> <H3>/home/steve</H3>
    #> <PRE>
    #>     Dirs     Files      Size
    #>     ----     -----      ----
    #>       17        34      5.5M
    #> </PRE>
    ```

    -   The script checks if the current user is root.
    -   If root, it lists all home directories; otherwise, it lists the current user’s home directory.
    -   It sets the directory list accordingly (/home/\* for all users or \$HOME for the current user).
    -   For each directory, it counts files and subdirectories using find and calculates size with du.
    -   The output is formatted in a table-like structure for clarity.

-   Setting and Executing Scripts with Arguments\
    ![](_resources/CLI.resources/lin-script-arg-1.png){.lightbox width="532"}

-   Template

    ``` bash
    #!/usr/bin/env bash
    set -o errexit
    set -o nounset
    set -o pipefail
    if [[ -n "${TRACE-}" ]]; then
        set -o xtrace
    fi
    if [[ "$1" =~ ^-*h(elp)?$ ]]; then
        echo 'Usage: ./script.sh arg-one arg-two
    This is an awesome bash script to make your life better.
    '
        exit
    fi
    cd "$(dirname "$0")"
    main() {
        echo do awesome stuff
    }
    main "$@"
    ```

## Debugging

![](_resources/CLI.resources/bash-debugging-x-trap-die-1.png){.lightbox width="532"}

-   Also see `set -o xtrace` in [Scripting](cli-linux.qmd#sec-cli-lin-script){style="color:green"} \>\> Commands that should start your script

## Job Management {#sec-cli-lin-jobm .unnumbered}

-   Programs/Scripts will by default run in the foreground, and prevent you from doing anything else until the program is done.

-   While program is running:

    -   [control+c]{.arg-text} - Will send a SIGINT (signal interrupt) signal to the program, which instructs the machine to interrupt the program immediately (unless the program has a way to handle these signals internally).
    -   [control+z]{.arg-text} - Will pause the program.
        -   After pausing the program can be continued either by bringing it to the foreground (`fg`), or by sending it to the backgroud (`bg`).

-   Execute script to run in the background:

    -   [Example]{.ribbon-highlight}: Basic `python run.py &`

    -   [Example]{.ribbon-highlight}: `nohup uv run main.py > script.log 2>&1 &`

        -   `nohup` - "No hangup" - ensures the process continues running even if the terminal session ends or the user logs out.

        -   `uv run main.py` - Uses `uv` (a fast Python package installer and resolver) to run `main.py` with the proper Python environment.

        -   `> script.log` - Redirects standard output (stdout) to a file named `script.log`.

        -   `2>&1` - Redirects standard error (stderr) to the same place as stdout (the `script.log` file).

            -   `2` = stderr (file descriptor 2)
            -   `&1` = "to the same place as file descriptor 1 (stdout)"

        -   `&` - Runs the command in the background, returning control to the terminal immediately.

-   `jobs` - Shows all running jobs and process ids (PIDS)

-   `ps` (process status) - Provides a static snapshot of active processes at the moment of execution.

    -   Ideal for scripting, logging, or analyzing processes at a specific point in time.

-   `ps aux`

    -   `a`: Displays processes from all users, not just the current user.
    -   `u`: Formats output with user-oriented details like CPU and memory usage.
    -   `x`: Includes processes without an attached terminal, such as daemons and background services.
    -   See [article](https://hostman.com/tutorials/using-the-ps-aux-command-in-linux/) for usage

-   `top` or `htop` - Monitor active processes in real-time

-   `kill` - Sends signals to jobs running in the background

    -   `kill -STOP %1` sends a STOP signal, pausing program 1.
    -   `kill -KILL %1` sends a KILL signal, terminating program 1 permanently

-   Kill all processes using a certain port (e.g. tcp 3000)

    ``` bash
    fuser -k 3000/tcp
    sudo fuser -k 3000/tcp
    ```

-   Some processes restart after being killed. If so, then you have to manually stop each one

    ``` bash
    sudo systemctl stop apache2
    ```

-   List of open ports and network connections

    ``` bash
    lsof -i
    #>  COMMAND     PID            USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
    #>  sshd        920            root    3u  IPv4    20507      0t0  TCP *:ssh (LISTEN)
    #>  sshd        920            root    4u  IPv6    20535      0t0  TCP *:ssh (LISTEN)
    #>  docker-pr  1163            root    4u  IPv6    21687      0t0  TCP *:https (LISTEN)
    #>  docker-pr  1175            root    4u  IPv6    21717      0t0  TCP *:http (LISTEN)
    #>  sshd       7528            root    3u  IPv4 39506588      0t0  TCP testing:ssh->212.91.91.19:58904 (ESTABLISHED)
    #>  systemd-r 10993 systemd-resolve   12u  IPv4 20901990      0t0  UDP localhost:domain 
    #>  systemd-r 10993 systemd-resolve   13u  IPv4 20901991      0t0  TCP localhost:domain (LISTEN)

    lsof -i :<port_number>
    lsof -i tcp
    lsof -i tcp:3000
    ```

    -   `lsof` is typically used for finding files opened by processes (See [Commands \>\> Files/Directories](cli-linux.qmd#sec-cli-lin-com-file){style="color: green"})

## tmux {#sec-cli-lin-tmux .unnumbered}

-   Terminal Multiplexer
-   Enables you to easily create new terminal sessions and navigate between them. This can be extremely useful, for example you can use one terminal to navigate your file system and another terminal to execute jobs.
-   [Installation]{.underline} (if necessary): `sudo apt install tmux`
    -   Typically comes with the linux installation
-   [Sessions]{.underline}
    -   `tmux` - starts an unnamed session
    -   `tmux new -s moose` creates new terminal session with name 'moose'
    -   `tmux ls` - lists all running sessions
    -   `tmux kill-session -t moose` - kills session named "moose"
    -   `exit` - stops and quits the current session
    -   Kill all sessions (various opinions on how to do this)
        -   `tmux kill-session`
        -   `tmux kill-server`
        -   `tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill`
-   [Attach/Detach]{.underline}
    -   When you log out of a remote machine (either on purpose or accidentally), all of the programs that were actively running inside your shell are automatically terminated. On the other hand, if you run your programs inside a tmux shell, you can come simply detach the tmux window, log out, *close* your computer, and come back to that shell later as if you've never been logged out.
    -   `tmux detach` - detach current session
    -   [control+b]{.arg-text}`then press`d\`: When you have multiple sesssions running, this will allow you to select the session to detach
    -   From inside bash and not inside a session
        -   `tmux a` : attach to latest created session
        -   `tmux a -t moose` : attach to session called 'moose'
-   [Pane Creation and Navigation]{.underline}
    -   [control+b]{.arg-text} then press ["]{.arg-text} (i.e. [shift+']{.arg-text}): add another terminal pane below
    -   [control+b]{.arg-text} then press [%]{.arg-text} (i.e. [shift+5]{.arg-text}) : add another terminal pane to the right
    -   [control+b]{.arg-text} then press [→]{.arg-text} : move to the terminal pane on the right (similar for left, up, down)

## SSH {#sec-cli-lin-ssh .unnumbered}

-   Typically uses a key pair to log into remote machines
    -   Key pair consists of a public key (which both machines have access to) and a private key (which only your own machine has access to)
    -   "ssh-keygen" is a program for generating such a key pair.
        -   If you run ssh-keygen, it will by default create a public key named "id_rsa.pub" and a private key named "id_rsa", and place both into your "\~/.ssh" directory
        -   You'll need to add the public key to the remote machine by piping together cat, ssh, and a streaming operator
            -   `cat .ssh/id_rsa.pub | ssh user@remote 'cat >> ~/.ssh/authorized_keys'`
-   Connect to the remote machine: `ssh remote -i ~/.ssh/id_rsa`
-   Create a config file instead
    -   Location: "\~/.ssh/config"

    -   Contents

        ```         
        Host dev
          HostName remote
          IdentityFile ~/.ssh/id_rsa
        ```
-   Connect using config: `ssh dev`
-   For Windows and using Putty, see
    -   [AWS \>\> EC2 \>\> Connect to/ Terminate Instance](aws.qmd#sec-aws-ec2-conterm){style="color: green"}
    -   Projects Notebook \>\> Article, Nested Cross Validation \>\> Notes \>\> Running EC2 instances checklist

## Packages {#sec-cli-lin-pkg .unnumbered}

-   Notes from
    -   [A Beginner’s Guide to Package Management in Linux](https://www.spsanderson.com/steveondata/posts/2024-12-06/)
-   Common package managers: apt, Pacman, yum, and portage
    -   Debian, Ubuntu: apt, dpkg (low-level)
    -   Red Hat-based: yum, rpm (low-level)
-   [APT]{.underline} (Advanced Package Tool)
    -   The `apt` command is a smaller section of the `apt` and `apt-cache` options. The `apt` command gives the end user just enough tools to install, remove, search and update APT packages. The `apt` command has a lot more options that are useful for writing low-level scripts and tools.

    -   Install Packages

        ``` bash
        # one pkg
        sudo apt install <package_name>
        # multiple
        sudo apt install <pkg_name1> <pkg_name2>
        ```

        -   Install but no upgrade: `sudo apt install <pkg_name> --no-upgrade`

    -   Install a package file from a file

        ``` bash
        dpkg –install <package_file>
        ```

    -   Remove a package

        ``` bash
        apt remove <package_name>
        ```

    -   List installed packages: `dpkg –list`

    -   Search for an installed package: `apt-cache search <pkg_name>`

    -   Get package information:

        ``` bash
        apt-cache show <package_name>
        dpkg –status <package_name>
        ```

    -   Update package information prior to "upgrading" the packages

        ``` bash
        sudo apt update
        ```

        -   Downloads the package lists from the repositories and "updates" them to get information on the newest versions of packages and their dependencies.

    -   Upgrade

        ``` bash
        # all installed packages
        sudo apt upgrade

        # To upgrade only a specific program
        sudo apt upgrade <package_name>

        # Upgrades and handles dependencies; delete obsolete, add new
        apt dist-upgrade

        # together
        sudo apt update && sudo apt dist-upgrade
        ```

        -   Can add these flags after `update` to get a less verbose output
            -   `-q` (quiet): Reduces output, shows less detailed information
            -   `-qq` (very quiet): Minimal output, only shows errors and critical information
            -   `-qqq`: Even more quiet (though rarely used)

    -   Upgrade from a file: `dpkg –install <package_file>`

    -   Backtrace file installation to a package: `dpkg –search <file_name>`
-   [yum]{.underline}
    -   Install packages

        ``` bash
        yum install <package_name>
        ```

    -   Install a package file from a non-repository source

        ``` bash
        rpm -i <package_file>
        ```

    -   Remove a package

        ``` bash
        yum erase <package_name>
        ```

    -   List installed packages: `rpm -qa`

    -   Search for an installed package

        ``` bash
        yum search <package_name>
        ```

    -   Get package information:

        ``` bash
        yum info <package_name>
        rpm -q <package_name>
        ```

    -   Update installed packages: `yum update`

    -   Upgrade from file: `rpm -U package_file`

    -   Backtrace a file installation to a package: `rpm -qf <file_name>`

## Expressions {#sec-cli-lin-expr .unnumbered}

-   Sort data, filter only unique lines, and write to file: `cat adult_t.csv | sort | uniq -c > sorted_list.csv`
