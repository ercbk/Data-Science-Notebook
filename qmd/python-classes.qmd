# Classes {#sec-py-class .unnumbered}

## Misc {#sec-py-class-misc .unnumbered}

-   When to use classes:
    -   When you have a group of functions and they have many of the same arguments, this indicates a class might be helpful. Also, if one or more of the functions is used in the other functions, this is also an indication that creating a class would be better.
        -   See [Python, Snippets \>\> Refactor a group of functions into a class](python-snippets.qmd#sec-py-snip-refclfun){style="color: green"}
    -   When you have code and data that go together and need to keep track of the current state
        -   e.g. managing a bunch of students and grades
    -   When you see hierarchies, using classes leads to better code organization, less duplication, and reusable code.
        -   You can make a single change in the base class (parent) and all child classes pick up the change
        -   [Example]{.ribbon-highlight}: Report class
            -   You can have a base class with shared attributes like report name, location and rows. But when you go into specifics like formats (xml, json, html), you could override a generate_report method in the subclass.
    -   Encapsulation
        -   When you want to separate external and internal interfaces in order to (ostensibly) hide internal code from the user.
        -   Keeps excess complexity from the user
-   Best Practices
    -   Use camel case for class names
    -   Use snake case for methods and attributes
    -   Always use self as the first argument of a method
    -   Write docstrings for your classes so that your code is more understandable to potential collaborators and future you.
-   Create a Class that allows method chaining\
    ![](./_resources/Python,_Classes.resources/image.png){.lightbox width="280"}
    -   `return self` is what allows the chaining to happen

## Terms {#sec-py-class-terms .unnumbered}

-   [**Class inheritance**]{style="color: #009499"} - mechanism by which one class takes on the attributes and methods of another

    ``` python
    class Employee:
    Â  Â  def __init__(self, name, salary=0):
    Â  Â  Â  Â  self.name = name
    Â  Â  Â  Â  self.salary = salary
    ```

-   `__init__()` is a [**constructor method**]{style="color: #009499"}. It assigns (or initializes) attributes that every object (aka instance) for this class must have.

-   `self` is the 1st argument in any method definition. It refers to a particular instance.

-   `self.salaryÂ  = salary` creates an attribute calledÂ salaryÂ and assigns to it the value of theÂ salaryÂ parameter (default set to 0)

-   [**Class attributes**]{style="color: #009499"} are attributes that have the same value for all class instances.

    -   Accessing a class attribute

        ``` python
        # access first employee's name attribute
        e1.name
        # access second employee's salary attribute
        e2.salary
        ```

-   [**Instance Attributes**]{style="color: #009499"} - Values for these attribute depend on the instance (e.g. they vary depending on each employee)

-   [**Instantiate**]{style="color: #009499"} - Creating a new object from a class

    ``` python
    e1 = Employee("yyy", 5000)Â  # name, salary
    e2 = Employee("zzz", 8000)
    ```

## Methods {#sec-py-class-meth .unnumbered}

### Misc

-   In most classes, best practice to at least include `__init__` and `__repr__` methods

### Instance Method {#sec-py-class-meth-inst .unnumbered}

-   Functions that can only be called by an object from this class

    -   Similar to regular functions with the difference of having "self" as the first parameter

    ``` python
    class Employee:
    Â  Â  def __init__(self, name, salary=0):
    Â  Â  Â  Â  self.name = name
    Â  Â  Â  Â  self.salary = salary

    #Instance method
    Â  Â  def give_raise(self, amount):
    Â  Â  Â  Â  self.salary += amount
    Â  Â  Â  Â  return f"{self.name} has been given a {amount} raise"

    # calling an instance method
    # instantiate object first
    object = MyClass()Â 
    object.method()
    ```

### Dunder Methods {#sec-py-class-meth-dund .unnumbered}

-   aka Magic or Special Methods

-   Resources

    -   [Every dunder method in Python](https://www.pythonmorsels.com/every-dunder-method/)

-   Aren't meant to be called, usually invoked by an operation

    -   Examples

        -   `__add__` invoked by `myclass() + myclass()`
        -   `__str__` invoked by `str(myclass())`

    -   [Example]{.ribbon-highlight}

        ``` python
        class Address:
        Â  Â  def __init__(self, street, city, state, zipcode, street2=''):
        Â  Â  Â  Â  self.street = street
        Â  Â  Â  Â  self.street2 = street2
        Â  Â  Â  Â  self.city = city
        Â  Â  Â  Â  self.state = state
        Â  Â  Â  Â  self.zipcode = zipcode
        Â  Â  def __str__(self):
        Â  Â  Â  Â  lines = [self.street]
        Â  Â  Â  Â  if self.street2:
        Â  Â  Â  Â  Â  Â  lines.append(self.street2)
        Â  Â  Â  Â  lines.append(f'{self.city}, {self.state} {self.zipcode}')
        Â  Â  Â  Â  return '\n'.join(lines)

        >>> address = Address('55 Main St.', 'Concord', 'NH', '03301')
        >>> print(address)
        55 Main St.
        Concord, NH 03301
        ```

-   Can be an instance or class type of method

    ``` python
    from datetime import datetime, timedelta
    from typing import Iterable
    from math import ceil
    class DateTimeRange:
    Â  Â  def __init__(self, start: datetime, end_:datetime, step:timedelta = timedelta(seconds=1)):
    Â  Â  Â  Â  self._start = start
    Â  Â  Â  Â  self._end = end_
    Â  Â  Â  Â  self._step = step

    Â  Â  def __iter__(self) -> Iterable[datetime]:
    Â  Â  Â  Â  point = self._start
    Â  Â  Â  Â  while point < self._end:
    Â  Â  Â  Â  Â  Â  yield point
    Â  Â  Â  Â  Â  Â  point += self._step

    Â  Â  def __len__(self) -> int:
    Â  Â  Â  Â  Â  Â  return ceil((self._end - self._start) / self._step)

    Â  Â  def __contains__(self, item: datetime) -> bool:
    Â  Â  Â  Â  Â  Â  mod = divmod(item - self._start, self._step)
    Â  Â  Â  Â  Â  Â  return item >= self._start and item < self._end and mod[1] == timedelta(0)

    Â  Â  def __getitem__(self, item: int) -> datetime:
    Â  Â  Â  Â  n_steps = item if item >= 0 else len(self) + item
    Â  Â  Â  Â  return_value = self._start + n_steps * self._step
    Â  Â  Â  Â  if return_value not in self:
    Â  Â  Â  Â  Â  Â  raise IndexError()
    Â  Â  Â  Â  return return_valueÂ 

    Â  Â  def __str__(self):
    Â  Â  Â  Â  return f"Datetime Range [{self._start}, {self._end}) with step {self._step}"
    ```

    -   Class DateTimeRange has methods that allows you to treat a date-range object like a list

        -   Just for illustration. Think methods in pandas can do this stuff

    -   `__iter__` method - [**generator function**]{style="color: #009499"} that creates one element at a time, yields it to the caller, and allows the caller to process it

        -   Example creates datetime ranges instead of numeric ranges

    -   `__len__` - find out the number of elements that are part of your range

    -   `__getitem__`- uses indexing syntax to retrieve entries from your objects

    -   `__contains__`- checks if an element is part of your range. T/F

        -   `divmod` returns quotient and remainder.

    -   Using these magic methods

        ``` python
        my_range = DateTimeRange(datetime(2021,1,1), datetime(2021,12,1), timedelta(days=12)) #instantiate
        print(my_range)Â  Â  Â  Â  Â  Â  Â  # __init__ or maybe __str__
        for r in my_range:Â  Â  Â  Â  Â  # __iter__
        Â  Â  do_something(r)
        len(my_range)Â  Â  Â  Â  Â  Â  Â  Â  # __len__
        my_range[-2] in my_rangeÂ  Â  # __getitem__ (neg indexing), __contains__
        ```

-   Others

    -   `__repr__` - Creates a string representation of the class object

        -   [Example]{.ribbon-highlight}

            ``` python
            class Person:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age

                def __repr__(self):
                    return f"Person(name='{self.name}', age={self.age})"

            person = Person("John", 25)
            print(person)
            #> Person(name='John', age=25)
            ```

    -   `__eq__` - Provides a method for comparing two class objects by their values.

        -   [Example]{.ribbon-highlight}

            ``` python
            class Person:
              def __init__(self, age):
                self.age = age

              def __eq__(self, other):
                return self.age == other.age

            alice = Person(18)
            bob = Person(19)
            carl = Person(18)

            print(alice == bob)
            #> False

            print(alice == carl)
            #> True
            ```

## Inheritance {#sec-py-class-inher .unnumbered}

![](./_resources/Python,_Classes.resources/ic-inheritance-policies.jpg){.lightbox width="571"}

-   Some notes from this much more detailed example ([article](https://realpython.com/inheritance-composition-python/))

    -   Shows how to combine different scriptsÂ  (aka modules) and diagram the hierarchies
    -   Some good debugging too
        -   Running `<class>.__mro__`will show you the order of inheritance.

-   Inheritance models what is called an "is a" relationship. This means that when you have a [**Derived (aka subclass, child) class**]{style="color: #009499"} that *inherits* from a [**Base (aka super, parent) class**]{style="color: #009499"}, you created a relationship where Derived is a specialized version of Base.

-   Child classes inherit all of their parent's attributes and methods, but they can also define their own attributes and methods.

-   Can override or extend parent class attributes and methods

    ``` python
    class Manager(Employee):
    Â  Â  pass

    m1 = Manager("aaa", 13000)
    ```

    -   Manager is the child class and Employee is the parent class (see top)
    -   Child classes don't require a constructor method for an object to be created

-   Extending the instance attributes of the parent class

    ``` python
    class Manager(Employee):
    Â  Â  def __init__(self, name, salary=0, department):
    Â  Â  Â  Â  Employee.__init__(self, name, salary=0)
    Â  Â  Â  Â  self.department = department
    ```

    -   Contructor method for the child class with the new attribute, "department," in the arguments.
    -   Parent class (Employee) constructor method is called and a new attribute, department, is defined.

### `super()` {#sec-py-class-inher-super .unnumbered}

-   Alternative way of extending instance attributes through inheritance

-   [Example]{.ribbon-highlight}

    ``` python
    class Rectangle:
    Â  Â  def __init__(self, length, width):
    Â  Â  Â  Â  self.length = length
    Â  Â  Â  Â  self.width = width
    Â  Â  def area(self):
    Â  Â  Â  Â  return self.length * self.width
    Â  Â  def perimeter(self):
    Â  Â  Â  Â  return 2 * self.length + 2 * self.width
    class Square(Rectangle):
    Â  Â  def __init__(self, length):
    Â  Â  Â  Â  super().__init__(length, length)
    class Cube(Square):
    Â  Â  def surface_area(self):
    Â  Â  Â  Â  face_area = super().area()
    Â  Â  Â  Â  return face_area * 6
    Â  Â  def volume(self):
    Â  Â  Â  Â  face_area = super().area()
    Â  Â  Â  Â  return face_area * self.length

    >>> cube = Cube(3)
    >>> cube.surface_area()
    54
    >>> cube.volume()
    27
    ```

    -   Class Cube inherits from Square and extends the functionality of .area() (inherited from the Rectangle class through Square) to calculate the surface area and volume of a Cube instance Also notice that the Cube class definition does not have an `.__init__()`. Because Cube inherits from Square and `.__init__()` doesn't really do anything differently for Cube than it already does for Square, you can skip defining it, and the `.__init__()` of the other child class (Square) will be called automatically.

    -   `super(Square, self).__init__(length, length)` is equivalent to calling super without parameters (see above example)

    -   Using `super(Square, self).area()` in class Cube. Setting the 1st parameter to Square instead of Cube causes super() to start searching for a matching method (in this case, .area()) at one level above Square in the instance hierarchy, in this case Rectangle.

        -   If Square had an .area method, but you wanted to use Rectangle's instead, this would be a way to do that.

    -   Note another difference between using super() and using the class name (e.g. the first example) --- "self" is NOT one of the args in super()

    -   [Example]{.ribbon-highlight}: Child class of two separate hierarchies

        ``` python
        # Super class
        class Rectangle:
        Â  Â  def __init__(self, length, width, **kwargs):
        Â  Â  Â  Â  self.length = length
        Â  Â  Â  Â  self.width = width
        Â  Â  Â  Â  super().__init__(**kwargs)
        Â  Â  def area(self):
        Â  Â  Â  Â  return self.length * self.width
        Â  Â  def perimeter(self):
        Â  Â  Â  Â  return 2 * self.length + 2 * self.width
        # Child class: Square class inherits from the Rectangle class
        class Square(Rectangle):
        Â  Â  def __init__(self, length, **kwargs):
        Â  Â  Â  Â  super().__init__(length=length, width=length, **kwargs)
        # Child class: Cube class inherits from Square and also from Rectangle classes
        class Cube(Square):
        Â  Â  def surface_area(self):
        Â  Â  Â  Â  face_area = super().area()
        Â  Â  Â  Â  return face_area * 6
        Â  Â  def volume(self):
        Â  Â  Â  Â  face_area = super().area()
        Â  Â  Â  Â  return face_area * self.length

        # Class (separate)
        class Triangle:Â 
        Â  Â  def __init__(self, base, height, **kwargs):Â 
        Â  Â  Â  Â  self.base = baseÂ 
        Â  Â  Â  Â  self.height = heightÂ 
        Â  Â  Â  Â  super().__init__(**kwargs)Â 
        Â  Â  def tri_area(self):Â 
        Â  Â  Â  Â  return 0.5 * self.base * self.height

        # Inherits from a child class (and super class) and a class
        class RightPyramid(Square, Triangle):
        Â  Â  def __init__(self, base, slant_height, **kwargs):
        Â  Â  Â  Â  self.base = base
        Â  Â  Â  Â  self.slant_height = slant_height
        Â  Â  Â  Â  kwargs["height"] = slant_height
        Â  Â  Â  Â  kwargs["length"] = base
        Â  Â  Â  Â  super().__init__(base=base, **kwargs)
        Â  Â  def area(self):
        Â  Â  Â  Â  base_area = super().area()
        Â  Â  Â  Â  perimeter = super().perimeter()
        Â  Â  Â  Â  return 0.5 * perimeter * self.slant_height + base_area
        Â  Â  def area_2(self):
        Â  Â  Â  Â  base_area = super().area()
        Â  Â  Â  Â  triangle_area = super().tri_area()
        Â  Â  Â  Â  return triangle_area * 4 + base_area

        >>> pyramid = RightPyramid(base=2, slant_height=4)
        >>> pyramid.area()
        20.0
        >>> pyramid.area_2()
        20.0
        ```

        -   RightPyramid inherits from a child class (Square) and a class Triangle
            -   Since Square inherits from Rectangle, so does RightPyramid
            -   Triangle is a separate class not part of any hierarchy
        -   If there's an .area method in either of the classes, then super will search hierarchy of the class listed first (Square), then the hierarchy of the class listed second (Triangle)
            -   Best practice to make sure each class has different method names.
        -   Each class with an `__init__` constructor gets a `super().__init__()` and `**kwargs` added to its args
            -   Which is every class sans Cube. If Cube was inherited by a class, I think it would require an \_\_init\_\_ constructor and the super().\_\_init\_\_(\*\*kwargs) expression.
            -   Without doing this, calling .area_2() in RightPyramid will give us an AttributeError since .base and .height don't have any values. (don't completely understand this explanation)
        -   kwarg flow through `super().__init__()`
            -   In RightPyramid \_\_init\_\_,Â  slant_height and base values are assigned to height and length keys in the kwargs dict
            -   super() passes base and the kwargs dict up to Square and Triangle
                -   Triangle uses height from kwargs and base
                -   Square uses length from kwargs
                    -   Square passes length to Rectangle as values for both width and length
            -   All classes now have the argument values necessary for their functions to work.
                -   Now RightPyramid can call those other classes' methods (e.g. .area and .perimeter from Rectangle and tri_area from Triangle)
            -   I believe since every class has \*\*kwargs arg in their super().\_\_init\_\_, each has every value in the kwarg dict even if they don't need it.
                -   So probably possible to add functions to those classes that would use those values

    -   [Example]{.ribbon-highlight}: Using super with method other than \_\_init\_\_

        ``` python
        class SalaryPolicy:Â 
        Â  Â  def __init__(self, weekly_salary):Â 
        Â  Â  Â  Â  self.weekly_salary = weekly_salaryÂ 
        Â  Â  def calculate_payroll(self):Â 
        Â  Â  Â  Â  return self.weekly_salary

        class CommissionPolicy(SalaryPolicy):Â 
        Â  Â  def __init__(self, weekly_salary, commission):Â 
        Â  Â  Â  Â  super().__init__(weekly_salary)Â 
        Â  Â  Â  Â  self.commission = commissionÂ 
        Â  Â  def calculate_payroll(self):Â 
        Â  Â  Â  Â  fixed = super().calculate_payroll()Â 
        Â  Â  Â  Â  return fixed + self.commission
        ```

        -   In CommissionPolicy's calculate_payroll, super() accesses SalaryPolicy's calculate_payroll method to get the weekly_salary value

### Diamond Problem {#sec-py-class-diam .unnumbered}

![](./_resources/Python,_Classes.resources/ic-diamond-problem.jpg){.lightbox width="368"}

-   Appears when you're using multiple inheritance and deriving from two classes that have a common base class.
    -   This can cause the wrong version of a method to be called.
    -   e.g. TemporarySecretary uses multiple inheritance to derive from two classes that ultimately also derive from Employee. This causes two paths to reach the Employee base class, which is something you want to avoid in your designs.

### Mixin Class {#sec-py-class-mix .unnumbered}

-   Operates the same as Inheritance, but since it only provides simple behavior(s), it is easy to reuse with other classes without causing problems

-   [Example]{.ribbon-highlight}: Take certain class attributes and create a dict

    ``` python
    # In representations.py
    class AsDictionaryMixin:
    Â  Â  def to_dict(self):
    Â  Â  Â  Â  return {
    Â  Â  Â  Â  Â  Â  prop: self._represent(value)
    Â  Â  Â  Â  Â  Â  for prop, value in self.__dict__.items()
    Â  Â  Â  Â  Â  Â  if not self._is_internal(prop)
    Â  Â  Â  Â  }
    Â  Â  def _represent(self, value):
    Â  Â  Â  Â  if isinstance(value, object):
    Â  Â  Â  Â  Â  Â  if hasattr(value, 'to_dict'):
    Â  Â  Â  Â  Â  Â  Â  Â  return value.to_dict()
    Â  Â  Â  Â  Â  Â  else:
    Â  Â  Â  Â  Â  Â  Â  Â  return str(value)
    Â  Â  Â  Â  else:
    Â  Â  Â  Â  Â  Â  return value
    Â  Â  def _is_internal(self, prop):
    Â  Â  Â  Â  return prop.startswith('_')
    ```

    -   `to_dict` is a dictionary comprehension
        -   `mydict = {key:val for key, val in dict}`
        -   Returns a dict with key:value (e.g. property (aka attribute):value) pairs from a class's \_\_dict\_\_ if the property (prop) doesn't have an underscore
    -   `_represent` makes sure the "value" is a value and not object
    -   `_is_interna1` checks whether the attribute has an underscore in the name

-   Apply the Mixin class to any class the same way as using Inheritance

    ``` python
    class Employee(AsDictionaryMixin):
    Â  Â  def __init__(self, id, name, address, role, payroll):
    Â  Â  Â  Â  self.id = id
    Â  Â  Â  Â  self.name = name
    Â  Â  Â  Â  self.address = address
    Â  Â  Â  Â  self._role = role
    Â  Â  Â  Â  self._payroll = payroll
    ```

    -   AsDicitionaryMixin is used as an arg to the class
    -   "self.\_role" and "self.\_payroll" have underscores which tells `to_dict` not to include them in the resulting dictionary
    -   Not important to using a mixin class but note that "address" is from the Address class via composition (see below). Therefore the Address class would also need to inherit AsDictionaryMixin for this to work

-   Utilize

    ``` python
    import json

    def print_dict(d):
    Â  Â  print(json.dumps(d, indent=2))

    for employee in EmployeeDatabase().employees:
    Â  Â  print_dict(employee.to_dict())
    ```

    -   `print_dict` takes the dict output of employee.\_to_dict and converts it to a json format

## Composition {#sec-py-class-comp .unnumbered}

![](./_resources/Python,_Classes.resources/ic-policy-based-composition.jpg){.lightbox width="557"}

-   Notes from [Inheritance and Composition: A Python OOP Guide](https://realpython.com/inheritance-composition-python/)
-   Composition models a "has a" relationship. In composition, a class known as **composite** contains an object of another class known to as **component**.
-   Composition design is typically more flexible than inheritance and is preferable to Inheritance
    -   Prevents "class explosion"
        -   For complex projects, too many classes can lead to conflicts and errors because of the inevitable complex network of classes that are connected to each other.
        -   You change your program's behavior by providing new components that implement those behaviors instead of adding new classes to your hierarchy.
    -   Only loose class connections in composition
        -   Changes to the component class rarely affect the composite class, and changes to the composite class never affect the component class
-   tl;dr
    -   Classes are written in different py scripts and imported as "modules" in another script.
    -   Attribute(s) from a component class (e.g. Address) are used in the composite class (e.g. Employee)
    -   Then a composite class attribute object is assigned to the instantiated composite class's empty attribute
        -   This is the magic. One class's attribute can be used as input into another class's attribute without being tightly coupled to that other class (aka inheritance).
            -   That input isn't a value. It's class type object.
            -   See Utilize code block below

### Composition Through \_\_init\_\_ Attributes

-   [Example]{.ribbon-highlight}:

    ``` python
    # In contacts.py
    # Component class
    class Address:
    Â  Â  def __init__(self, street, city, state, zipcode, street2=''):
    Â  Â  Â  Â  self.street = street
    Â  Â  Â  Â  self.street2 = street2
    Â  Â  Â  Â  self.city = city
    Â  Â  Â  Â  self.state = state
    Â  Â  Â  Â  self.zipcode = zipcode

    # In employees.py
    # Composite class
    class Employee:
    Â  Â  def __init__(self, id, name):
    Â  Â  Â  Â  self.id = id
    Â  Â  Â  Â  self.name = name
    Â  Â  Â  Â  self.address = None

    # ManagerRole and SalaryPolicy are classes from different modules
    class Manager(Employee, ManagerRole, SalaryPolicy):
    Â  Â  def __init__(self, id, name, weekly_salary):
    Â  Â  Â  Â  SalaryPolicy.__init__(self, weekly_salary)
    Â  Â  Â  Â  super().__init__(id, name)
    ```

    -   You would import these two modules into a third script and do stuff (see next code block)

    -   You initialize the Address.address attribute to "None" for now to make it optional, but by doing that, you can now assign an Address to an Employee.

        -   i.e. the attributes of an Address instance from its \_\_init\_\_ are now available to be assigned to a Employee instance.

    -   Manager is a child class of multiple other classes (inheritance) including Employee and therefore gets an .address attribute

        -   Aside: ManagerRole doesn't have an \_\_init\_\_ (i.e. no attributes), so I'm not sure why super() is used here
            -   why not just use Employee.\_\_init\_\_?
            -   I would've thought that ManagerRole would've required the same inputs as Employee, so super() is used here to cover both at the same time.
                -   But that's not the case, MangerRole is there just for it's method and not it's attributes
            -   Does being able to use ManageRole methods require super() (i.e. necessary for Inheritance)?

    -   Utilize

        ``` python
        manager = employees.Manager(1, 'Mary Poppins', 3000)
        manager.address = contacts.Address(
        Â  Â  '121 Admin Rd',Â 
        Â  Â  'Concord',Â 
        Â  Â  'NH',Â 
        Â  Â  '03301'
        )
        # ... create other intances of different jobs in the company

        # guess this would be like a json
        employees = [
        Â  Â  manager,
        Â  Â  secretary,
        Â  Â  sales_guy,
        Â  Â  factory_worker,
        Â  Â  temporary_secretary,
        ]

        # do work with the list class objs
        productivity_system = productivity.ProductivitySystem()
        productivity_system.track(employees, 40)
        ```

        -   The Address class instance is assigned to the .address attribute of the Manager instance (which gets its .address attribute from Employee)

### Composition Through a Function Argument

-   [Example]{.ribbon-highlight}:

    ``` python
    # In hr.py
    class PayrollSystem:
    Â  Â  def calculate_payroll(self, employees):
    Â  Â  Â  Â  print('Calculating Payroll')
    Â  Â  Â  Â  print('===================')
    Â  Â  Â  Â  for employee in employees:
    Â  Â  Â  Â  Â  Â  print(f'Payroll for: {employee.id} - {employee.name}')
    Â  Â  Â  Â  Â  Â  print(f'- Check amount: {employee.calculate_payroll()}')
    Â  Â  Â  Â  Â  Â  if employee.address:
    Â  Â  Â  Â  Â  Â  Â  Â  print('- Sent to:')
    Â  Â  Â  Â  Â  Â  Â  Â  print(employee.address)
    Â  Â  Â  Â  Â  Â  print('')

    payroll_system = hr.PayrollSystem()
    payroll_system.calculate_payroll(employees)
    ```

    -   The input for calculate_payroll, employees, is a list of instantiated Employee class objects in the previous code chunk.
    -   Name of the class is iterated and represents each instance
        -   Has attributes and methods available

### Other Module Classes Used as Attributes

-   [Example]{.ribbon-highlight}:

    ``` python
    # In employees.py
    from productivity import ProductivitySystem
    from hr import PayrollSystem
    from contacts import AddressBook
    class EmployeeDatabase:
    Â  Â  def __init__(self):
    Â  Â  Â  Â  self._employees = [
    Â  Â  Â  Â  Â  Â  {
    Â  Â  Â  Â  Â  Â  Â  Â  'id': 1,
    Â  Â  Â  Â  Â  Â  Â  Â  'name': 'Mary Poppins',
    Â  Â  Â  Â  Â  Â  Â  Â  'role': 'manager'
    Â  Â  Â  Â  Â  Â  },
    Â  Â  Â  Â  Â  Â  {
    Â  Â  Â  Â  Â  Â  Â  Â  'id': 2,
    Â  Â  Â  Â  Â  Â  Â  Â  'name': 'John Smith',
    Â  Â  Â  Â  Â  Â  Â  Â  'role': 'secretary'
    Â  Â  Â  Â  Â  Â  }
    Â  Â  Â  Â  ]
    Â  Â  Â  Â  self.productivity = ProductivitySystem()
    Â  Â  Â  Â  self.payroll = PayrollSystem()
    Â  Â  Â  Â  self.employee_addresses = AddressBook()
    Â  Â  @property
    Â  Â  def employees(self):
    Â  Â  Â  Â  return [self._create_employee(**data) for data in self._employees]
    Â  Â  def _create_employee(self, id, name, role):
    Â  Â  Â  Â  address = self.employee_addresses.get_employee_address(id)
    Â  Â  Â  Â  employee_role = self.productivity.get_role(role)
    Â  Â  Â  Â  payroll_policy = self.payroll.get_policy(id)
    Â  Â  Â  Â  return Employee(id, name, address, employee_role, payroll_policy)
    ```

    -   ProductivitySystem, PayrollSystem, AddressBook are classes imported from various modules
    -   As attributes, these classes' methods are used in the \_create_employee function
        -   Return invokes the Employee class with values obtained by the various class methods
        -   Employee class (not shown in this block) is already present in this module so it doesn't have to be imported.

## Decorators {#sec-py-class-dec .unnumbered}

-   They can add additional features to a function

    -   Useful because you don't have to refactor downstream code

-   Functions that take a function as input

    -   See use cases throughout note and check bkmks

-   \@<name> is placed above a "decorated" function

    -   [Example]{.ribbon-highlight}

        ``` python
        @decorator_1
        def temperature():
        return temp
        ```

        -   Calling `temperature()` is actually calling `decorator_1(temperature())`

-   [Example]{.ribbon-highlight}: add additional features to a function\
    ![](./_resources/Python,_Classes.resources/FKvqG6GXMAIyNqE.jpeg){.lightbox width="423"}

    -   Adds a timer to a function

-   [Example]{.ribbon-highlight}: Multiple decorators for a function

    ``` python
    @log_execution
    @timing
    def my_function(x, y):
    Â  Â  time.sleep(1)
    Â  Â  return x + y
    ```

-   See Custom Examples for the "log_execution" decorator

### Property {#sec-py-class-dec-prop .unnumbered}

-   Arguments

    ``` python
    property(fget=None, fset=None, fdel=None, doc=None)
    ```

-   Built-in decorator

-   Constitutes a family of decorators

    -   @property: Declares the method as a property.
        -   fget - function to get value of the attribute
    -   \@<property-name>.setter: Specifies the setter method for a property that sets the value to a property.
        -   fset - function to set value of the attribute
        -   must have the value argument that can be used to assign to the underlying private attribute
    -   \@<property-name>.deleter: Specifies the delete method as a property that deletes a property.
        -   fdel - function to delete the attribute
        -   must have the value argument that can be used to assign to the underlying private attribute

-   [Example]{.ribbon-highlight}

    ``` python
    # Using @property decorator
    class Celsius:
    def __init__(self, temperature=0):
    Â  Â  self._temperature = temperature
    def to_fahrenheit(self):
    Â  Â  return (self._temperature * 1.8) + 32


    # decorators
    # attribute getter
    @property
    def temperature(self):
    Â  Â  print("Getting value...")
    Â  Â  return self._temperature

    # also adds constraint to the temperature input
    @temperature.setter
    def temperature(self, value):
    Â  Â  print("Setting value...")
    Â  Â  if value < -273.15:
    Â  Â  Â  Â  raise ValueError("Temperature below -273 is not possible")
    Â  Â  self._temperature = value

    @temperature.deleter
    def temperature(self, value):
    Â  Â  print("Deleting value...")
    Â  Â  del self._temperature

    >> human = Celsius(37)
    Setting value...
    >> print(human.temperature)
    Getting value...
    37
    >> print(human.to_fahrenheit())
    Getting value...
    98.60000000000001
    >> del human.temperature
    Deleting value...
    >> coldest_thing = Celsius(-300)
    Setting value...
    Traceback (most recent call last):
    File "", line 29, in
    File "", line 4, in __init__
    File "", line 18, in temperature
    ValueError: Temperature below -273 is not possible
    ```

    -   .deleter didn't work for me and neither did the conditional. Don't my python version or what

### Class Method {#sec-py-class-dec-class .unnumbered}

-   Method that is bound to the class and not the object (aka instance) of the class.

-   Instance attributes cannot be referred to with this method

-   Can modify the class state that applies across all instances of the class

-   Use Cases

    -   To create new instances of the class without going trhough its normal `__init__`
    -   To create a class instance that requires some async calls when instantiated, since `__init__` cannot be async.

-   Starts with a "classmethod" decorator

    ``` python
    class MyClass:Â  Â 
    @classmethod
    def classmethod(cls):
    Â  Â  return 'class method called', cls
    ```

-   Calling a class method vs an instance method

    ``` python
    # calling a class method
    # no instantiation
    MyClass.classmethod()

    # calling an instance method
    # instantiates object first
    object = MyClass()
    object.method()
    ```

### Static Method {#sec-py-class-dec-stat .unnumbered}

-   Method bound to the class instance, not the class itself.

-   Does not take the class as a parameter.

-   It cannot access or modify the class at all.

-   Starts with a "staticmethod" decorator

-   Doesn't have any access to what the class is---it's basically just a function, called syntactically like a method, but without access to the object and its internals (fields and other methods), which classmethod does have.

-   See SO [thread](https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner) for discussion on the differences between the static and class decorators and their uses

    ``` python
    class Person:
    Â  def __init__(self, name, age):
    Â  Â  self.name = name
    Â  Â  self.age = age

    Â  @staticmethod
    Â  def isAdult(age):
    Â  Â  return age > 18
    ```

    -   isAdult(age) function doesn't require the usual self argument, so it couldn't reference the class even if it wanted to.
    -   Most often used as utility functions that are completely independent of a class's state
    -   See classmethod decorator for details on calling this method

### [{{functools}}]{style="color: goldenrod"}

-   Misc

    -   [Docs](https://docs.python.org/3/library/functools.html)

-   Caching

    ``` python
    import time
    from functools import cache

    @cache
    def slow_function (x):
      time.sleep(2)
      return x * x
    ```

### Custom Examples {#sec-py-class-dec-cust .unnumbered}

-   Also see [Code, Optimization \>\> Python](code-optimization.qmd#sec-code-opt-py){style="color: green"} \>\> Profile decorator

-   Using functools and decorators

    ``` python
    from functools import singledispatch

    @singledispatch
    def process_data(data):
    raise NotImplementedError(f"Type {type(data)} is unsupported")

    @process_data.register
    def process_dict(data: dict):
    print("Dict is processed")

    @process_data.register
    def process_list(data: list):
    print("List is processed")
    ```

-   Multiprocessing Function Execution Time Limiter

    ``` python
    import multiprocessing
    from functools import wraps

    class TimeExceededException(Exception):
    Â  Â  pass
    ## PART 1
    Â  Â  def function_runner(*args, **kwargs):
    Â  Â  Â  Â  """Used as a wrapper function to handle
    Â  Â  Â  Â  returning results on the multiprocessing side"""

    Â  Â  Â  Â  send_end = kwargs.pop("__send_end")
    Â  Â  Â  Â  function = kwargs.pop("__function")
    Â  Â  Â  Â  try:
    Â  Â  Â  Â  Â  Â  result = function(*args, **kwargs)
    Â  Â  Â  Â  except Exception as e:
    Â  Â  Â  Â  Â  Â  send_end.send(e)
    Â  Â  Â  Â  Â  Â  return
    Â  Â  Â  Â  send_end.send(result)

    Â  Â  @parametrized
    Â  Â  def run_with_timer(func, max_execution_time):
    Â  Â  Â  Â  @wraps(func)
    Â  Â  Â  Â  def wrapper(*args, **kwargs):
    Â  Â  Â  Â  Â  Â  recv_end, send_end = multiprocessing.Pipe(False)
    Â  Â  Â  Â  Â  Â  kwargs["__send_end"] = send_end
    Â  Â  Â  Â  Â  Â  kwargs["__function"] = func

    Â  Â  Â  Â  Â  Â  ## PART 2
    Â  Â  Â  Â  Â  Â  p = multiprocessing.Process(target=function_runner, args=args, kwargs=kwargs)
    Â  Â  Â  Â  Â  Â  p.start()
    Â  Â  Â  Â  Â  Â  p.join(max_execution_time)
    Â  Â  Â  Â  Â  Â  if p.is_alive():
    Â  Â  Â  Â  Â  Â  Â  Â  p.terminate()
    Â  Â  Â  Â  Â  Â  Â  Â  p.join()
    Â  Â  Â  Â  Â  Â  Â  Â  raise TimeExceededException("Exceeded Execution Time")
    Â  Â  Â  Â  Â  Â  result = recv_end.recv()

    Â  Â  Â  Â  Â  Â  if isinstance(result, Exception):
    Â  Â  Â  Â  Â  Â  Â  Â  raise result

    Â  Â  Â  Â  Â  Â  return result

    Â  Â  Â  Â  return wrapper
    ```

    -   From [Limiting Python Function Execution Time with a Parameterized Decorator via Multiprocessing](https://towardsdatascience.com/limiting-a-python-functions-execution-time-using-a-decorator-and-multiprocessing-6fcfe01da6f8)

-   Retry (e.g. for an API)

    ``` python
    import time
    from functools import wraps

    def retry(max_tries=3, delay_seconds=1):
    Â  Â  def decorator_retry(func):
    Â  Â  Â  Â  @wraps(func)
    Â  Â  Â  Â  def wrapper_retry(*args, **kwargs):
    Â  Â  Â  Â  Â  Â  tries = 0
    Â  Â  Â  Â  Â  Â  while tries < max_tries:
    Â  Â  Â  Â  Â  Â  Â  Â  try:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return func(*args, **kwargs)
    Â  Â  Â  Â  Â  Â  Â  Â  except Exception as e:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tries += 1
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if tries == max_tries:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  raise e
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  time.sleep(delay_seconds)
    Â  Â  Â  Â  return wrapper_retry
    Â  Â  return decorator_retry

    @retry(max_tries=5, delay_seconds=2)
    def call_dummy_api():
    Â  Â  response = requests.get("https://jsonplaceholder.typicode.com/todos/1")
    Â  Â  return response
    ```

    -   Tries to get an API response. If it fails, we retry the same task 5 times. Between each retry, we wait for 2 seconds.

-   Cache Function Results

    ``` python
    def memoize(func):
    Â  Â  cache = {}
    Â  Â  def wrapper(*args):
    Â  Â  Â  Â  if args in cache:
    Â  Â  Â  Â  Â  Â  return cache[args]
    Â  Â  Â  Â  else:
    Â  Â  Â  Â  Â  Â  result = func(*args)
    Â  Â  Â  Â  Â  Â  cache[args] = result
    Â  Â  Â  Â  Â  Â  return result
    Â  Â  return wrapper

    @memoize
    def fibonacci(n):
    Â  Â  if n <= 1:
    Â  Â  Â  Â  return n
    Â  Â  else:
    Â  Â  Â  Â  return fibonacci(n-1) + fibonacci(n-2)
    ```

    -   Uses a dictionary, stores the function args, and returns values. When we execute this function, the decorated will check the dictionary for prior results. The actual function is called only when there's no stored value before.
    -   Using a dictionary to hold previous execution data is a straightforward approach. However, there is a more sophisticated way to store caching data. You can use an in-memory database, such as Redis.

-   Logging (e.g. ETL pipeline)

    ``` python
    import logging
    import functools

    logging.basicConfig(level=logging.INFO)

    def log_execution(func):
    Â  Â  @functools.wraps(func)
    Â  Â  def wrapper(*args, **kwargs):
    Â  Â  Â  Â  logging.info(f"Executing {func.__name__}")
    Â  Â  Â  Â  result = func(*args, **kwargs)
    Â  Â  Â  Â  logging.info(f"Finished executing {func.__name__}")
    Â  Â  Â  Â  return result
    Â  Â  return wrapper

    @log_execution
    def extract_data(source):
    Â  Â  # extract data from source
    Â  Â  data = ...
    Â  Â  return data
    @log_execution
    def transform_data(data):
    Â  Â  # transform data
    Â  Â  transformed_data = ...
    Â  Â  return transformed_data
    @log_execution
    def load_data(data, target):
    Â  Â  # load data into target
    Â  Â  ...

    def main():
    Â  Â  # extract data
    Â  Â  data = extract_data(source)
    Â  Â  # transform data
    Â  Â  transformed_data = transform_data(data)
    Â  Â  # load data
    Â  Â  load_data(transformed_data, target)
    ```

    -   output

        ```         
        INFO:root:Executing extract_data
        INFO:root:Finished executing extract_data
        INFO:root:Executing transform_data
        INFO:root:Finished executing transform_data
        INFO:root:Executing load_data
        INFO:root:Finished executing load_data
        ```

-   Email Notification

    ``` python
    import smtplib
    import traceback
    from email.mime.text import MIMEText
    def email_on_failure(sender_email, password, recipient_email):
    Â  Â  def decorator(func):
    Â  Â  Â  Â  def wrapper(*args, **kwargs):
    Â  Â  Â  Â  Â  Â  try:
    Â  Â  Â  Â  Â  Â  Â  Â  return func(*args, **kwargs)
    Â  Â  Â  Â  Â  Â  except Exception as e:
    Â  Â  Â  Â  Â  Â  Â  Â  # format the error message and traceback
    Â  Â  Â  Â  Â  Â  Â  Â  err_msg = f"Error: {str(e)}\n\nTraceback:\n{traceback.format_exc()}"

    Â  Â  Â  Â  Â  Â  Â  Â  # create the email message
    Â  Â  Â  Â  Â  Â  Â  Â  message = MIMEText(err_msg)
    Â  Â  Â  Â  Â  Â  Â  Â  message['Subject'] = f"{func.__name__} failed"
    Â  Â  Â  Â  Â  Â  Â  Â  message['From'] = sender_email
    Â  Â  Â  Â  Â  Â  Â  Â  message['To'] = recipient_email

    Â  Â  Â  Â  Â  Â  Â  Â  # send the email
    Â  Â  Â  Â  Â  Â  Â  Â  with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  smtp.login(sender_email, password)
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  smtp.sendmail(sender_email, recipient_email, message.as_string())

    Â  Â  Â  Â  Â  Â  Â  Â  # re-raise the exception
    Â  Â  Â  Â  Â  Â  Â  Â  raise

    Â  Â  Â  Â  return wrapper

    Â  Â  return decorator

    @email_on_failure(sender_email='your_email@gmail.com', password='your_password', recipient_email='recipient_email@gmail.com')
    def my_function():
    Â  Â  # code that might fail
    ```

## Optimizations {#sec-py-class-opt .unnumbered}

-   Misc
    -   Notes from [How to Write Memory-Efficient Classes in Python](https://towardsdatascience.com/how-to-write-memory-efficient-classes-in-python-beb90811abfa)
-   [Use `__slots__` when creating large numbers of instances]{.underline}\
    ![](_resources/Python,_Classes.resources/opt-slots-memory-1.webp){.lightbox width="332"}
    -   By default, Python classes store their instance attributes in a private dictionary (`__dict__`), which dictionary allows you to add, modify, or delete the class attributes at runtime, but it creates a large memory burden when substantial numbers of instances are created.

    -   Slots reserves only a fixed amount of space for the specified attributes directly in each instance, instead of using the default dictionary.

    -   Any attempt to assign an attribute that is not listed inÂ `__slots__`Â will raise anÂ `AttributeError`.

        -   This can help prevent creating accidental attributes due to typos, but it can also be restrictive if you need to add additional attributes later in development.

    -   [Example]{.ribbon-highlight}:

        ``` python
        class Ant:
          __slots__ = ['worker_id', 'role', 'colony']

          def __init__(self, worker_id, role, colony):
              self.worker_id = worker_id
              self.role = role
              self.colony = colony
        ```
-   [Lazy Initialization for memory intensive operations]{.underline}
    -   Scenario: Data Loading in an app

        -   User wants to look at map or examine features before analyzing data.
        -   Without Lazy Loading, the entire dataset is loaded upfront, leading to slower startup and potentially exceeding memory limits.

    -   Caching is also a good idea if you're performing the same intensive computation more than once.

    -   [Example]{.ribbon-highlight}: Lazy Loader

        ``` python
        from functools import cached_property

        class DataLoader:

            def __init__(self, path):
                self.path = path

            @cached_property
            def dataset(self):
                # load the dataset here
                # this will only be executed once when the dataset property is first accessed
                return self._load_dataset()

            def _load_dataset(self):
                print("Loading the dataset...")

                # load a big dataset here
                df = pd.read_csv(self.path)
                return df

        class DataProcessor:
            def __init__(self, path):
                  self.path = path
                self.data_loader = DataLoader(self.path)

            def process_data(self):
                dataset = self.data_loader.dataset
                print("Processing the dataset...")
                # Perform complex data processing steps on the loaded dataset
                ...

        # instantiate the DataLoader class
        path = "/[path_to_dataset]/mnist.csv"

        # instantiate the DataProcessor class with the data file path
        # ðŸ‘‰ no data will be loaded at this stage! âœ…
        processor = DataProcessor(path)

        # trigger the processing
        processor.process_data()  # The dataset will be loaded and processed when needed
        ```
-   [Use generators to reduce memory usage of loops]{.underline}
    -   See [Python, General \>\> Loops \>\> Generators](python-general.qmd#sec-py-gen-loops-gen){style="color: green"}

        -   Also, in Loops \>\> Misc, there's a chart that shows the memory benefits to using a generator vs list comprehension.

## Examples {#sec-py-class-examp .unnumbered}

-   Read file chunks, process, and write to parquet

    ``` python
    import pandas as pd

    class PandasChunkProcessor:
        def __init__(self, filepath, chunk_size, verbose=True):
            self.filepath = filepath
            self.chunk_size = chunk_size
            self.verbose = verbose

        def process_data(self):
            for chunk_id, chunk in enumerate(pd.read_csv(self.filepath, chunksize=self.chunk_size)):
                processed_chunk = self.process_chunk(chunk)
                self.save_chunk(processed_chunk, chunk_id)

        def process_chunk(self, chunk):
            # process each chunk of data
            processed_chunk = processing_function(chunk)
            return processed_chunk

        def save_chunk(self, chunk, chunk_id):
            # save each processed chunk to a parquet file
            chunk_filepath = f"./output_chunk_{chunk_id}.parquet"
            chunk.to_parquet(chunk_filepath)
            if self.verbose:
                print(f"saved {chunk_filepath}")
    ```

-   Transforms variables by logging, can add 1 if necessary, back-transform

    ``` python
    from sklearn.base import BaseEstimator, TransformerMixinÂ 
    from sklearn.preprocessing import PowerTransformerÂ 

    class CustomLogTransformer(BaseEstimator, TransformerMixin):Â 
    Â  Â  def __init__(self):Â 
    Â  Â  Â  Â  self._estimator = PowerTransformer()Â  # init a transformerÂ 
    Â  Â  def fit(self, X, y=None):Â 
    Â  Â  Â  Â  X_copy = np.copy(X) + 1Â  # add one in case of zeroesÂ 
    Â  Â  Â  Â  self._estimator.fit(X_copy)Â 
    Â  Â  Â  Â  return selfÂ 
    Â  Â  def transform(self, X):Â 
    Â  Â  Â  Â  X_copy = np.copy(X) + 1Â 
    Â  Â  Â  Â  return self._estimator.transform(X_copy)Â  # perform scalingÂ 
    Â  Â  def inverse_transform(self, X):Â 
    Â  Â  Â  Â  X_reversed = self._estimator.inverse_transform(np.copy(X))Â 
    Â  Â  Â  Â  return X_reversed - 1Â  # return subtracting 1 after inverse transform
    ```

-   Predictions for a Huggingface classifer

    ``` python
    import sys
    from transformers import pipeline
    from typing import List
    import numpy as np
    from time import perf_counter
    import logging

    # Set up logger
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    log = logging.getLogger(__name__)

    class ZeroShotTextClassifier:
    Â  Â  """Class with only class methods"""
    Â  Â  # Class variable for the model pipeline
    Â  Â  classifier = None
    Â  Â  @classmethod
    Â  Â  def load(cls):
    Â  Â  Â  Â  # Only load one instance of the model
    Â  Â  Â  Â  if cls.classifier is None:
    Â  Â  Â  Â  Â  Â  # Load the model pipeline.
    Â  Â  Â  Â  Â  Â  # Note: Usually, this would also download the model.
    Â  Â  Â  Â  Â  Â  # But, we download the model into the container in the Dockerfile
    Â  Â  Â  Â  Â  Â  # so that it's built into the container and there's no download at
    Â  Â  Â  Â  Â  Â  # run time (otherwise, each time we'll download a 1.5GB model).
    Â  Â  Â  Â  Â  Â  # Loading still takes time, though. So, we do that here.
    Â  Â  Â  Â  Â  Â  # Note: You can use a GPU here if needed.
    Â  Â  Â  Â  Â  Â  t0 = perf_counter()
    Â  Â  Â  Â  Â  Â  cls.classifier = pipeline(
    Â  Â  Â  Â  Â  Â  Â  Â  "zero-shot-classification", model="facebook/bart-large-mnli"
    Â  Â  Â  Â  Â  Â  )
    Â  Â  Â  Â  Â  Â  elapsed = 1000 * (perf_counter() - t0)
    Â  Â  Â  Â  Â  Â  log.info("Model warm-up time: %d ms.", elapsed)
    Â  Â  @classmethod
    Â  Â  def predict(cls, text: str, candidate_labels: List[str]):
    Â  Â  Â  Â  assert len(candidate_labels) > 0
    Â  Â  Â  Â  # Make sure the model is loaded
    Â  Â  Â  Â  cls.load()
    Â  Â  Â  Â  # For the tutorial, let's create
    Â  Â  Â  Â  # a custom object from the huggingface prediction.
    Â  Â  Â  Â  # Our prediction object will include the label and score
    Â  Â  Â  Â  t0 = perf_counter()
    Â  Â  Â  Â  # pylint: disable-next=not-callable
    Â  Â  Â  Â  huggingface_predictions = cls.classifier(text, candidate_labels)
    Â  Â  Â  Â  elapsed = 1000 * (perf_counter() - t0)
    Â  Â  Â  Â  log.info("Model prediction time: %d ms.", elapsed)
    Â  Â  Â  Â  # Create the custom prediction object.
    Â  Â  Â  Â  max_index = np.argmax(huggingface_predictions["scores"])
    Â  Â  Â  Â  label = huggingface_predictions["labels"][max_index]
    Â  Â  Â  Â  score = huggingface_predictions["scores"][max_index]
    Â  Â  Â  Â  return {"label": label, "score": score}
    ```

-   Payroll System

    -   Employees

        ``` python
        # In employees.py
        from hr import (
        Â  Â  SalaryPolicy,
        Â  Â  CommissionPolicy,
        Â  Â  HourlyPolicy
        )
        from productivity import (
        Â  Â  ManagerRole,
        Â  Â  SecretaryRole,
        Â  Â  SalesRole,
        Â  Â  FactoryRole
        )
        class Employee:
        Â  Â  def __init__(self, id, name):
        Â  Â  Â  Â  self.id = id
        Â  Â  Â  Â  self.name = name
        class Manager(Employee, ManagerRole, SalaryPolicy):
        Â  Â  def __init__(self, id, name, weekly_salary):
        Â  Â  Â  Â  SalaryPolicy.__init__(self, weekly_salary)
        Â  Â  Â  Â  super().__init__(id, name)
        class Secretary(Employee, SecretaryRole, SalaryPolicy):
        Â  Â  def __init__(self, id, name, weekly_salary):
        Â  Â  Â  Â  SalaryPolicy.__init__(self, weekly_salary)
        Â  Â  Â  Â  super().__init__(id, name)
        class SalesPerson(Employee, SalesRole, CommissionPolicy):
        Â  Â  def __init__(self, id, name, weekly_salary, commission):
        Â  Â  Â  Â  CommissionPolicy.__init__(self, weekly_salary, commission)
        Â  Â  Â  Â  super().__init__(id, name)
        class FactoryWorker(Employee, FactoryRole, HourlyPolicy):
        Â  Â  def __init__(self, id, name, hours_worked, hour_rate):
        Â  Â  Â  Â  HourlyPolicy.__init__(self, hours_worked, hour_rate)
        Â  Â  Â  Â  super().__init__(id, name)
        class TemporarySecretary(Employee, SecretaryRole, HourlyPolicy):
        Â  Â  def __init__(self, id, name, hours_worked, hour_rate):
        Â  Â  Â  Â  HourlyPolicy.__init__(self, hours_worked, hour_rate)
        Â  Â  Â  Â  super().__init__(id, name)
        ```

    -   Productivity

        ``` python
        # In productivity.py
        class ProductivitySystem:
        Â  Â  def track(self, employees, hours):
        Â  Â  Â  Â  print('Tracking Employee Productivity')
        Â  Â  Â  Â  print('==============================')
        Â  Â  Â  Â  for employee in employees:
        Â  Â  Â  Â  Â  Â  result = employee.work(hours)
        Â  Â  Â  Â  Â  Â  print(f'{employee.name}: [{result}]')
        Â  Â  Â  Â  print('')
        class ManagerRole:
        Â  Â  def work(self, hours):
        Â  Â  Â  Â  return f'screams and yells for [{hours}] hours.'
        class SecretaryRole:
        Â  Â  def work(self, hours):
        Â  Â  Â  Â  return f'expends [{hours}] hours doing office paperwork.'
        class SalesRole:
        Â  Â  def work(self, hours):
        Â  Â  Â  Â  return f'expends [{hours}] hours on the phone.'
        class FactoryRole:
        Â  Â  def work(self, hours):
        Â  Â  Â  Â  return f'manufactures gadgets for [{hours}] hours.'
        ```

    -   HR

        ``` python
        # In hr.py
        class PayrollSystem:
        Â  Â  def calculate_payroll(self, employees):
        Â  Â  Â  Â  print('Calculating Payroll')
        Â  Â  Â  Â  print('===================')
        Â  Â  Â  Â  for employee in employees:
        Â  Â  Â  Â  Â  Â  print(f'Payroll for: {employee.id} - {employee.name}')
        Â  Â  Â  Â  Â  Â  print(f'- Check amount: {employee.calculate_payroll()}')
        Â  Â  Â  Â  Â  Â  print('')
        class SalaryPolicy:
        Â  Â  def __init__(self, weekly_salary):
        Â  Â  Â  Â  self.weekly_salary = weekly_salary
        Â  Â  def calculate_payroll(self):
        Â  Â  Â  Â  return self.weekly_salary
        class HourlyPolicy:
        Â  Â  def __init__(self, hours_worked, hour_rate):
        Â  Â  Â  Â  self.hours_worked = hours_worked
        Â  Â  Â  Â  self.hour_rate = hour_rate
        Â  Â  def calculate_payroll(self):
        Â  Â  Â  Â  return self.hours_worked * self.hour_rate
        class CommissionPolicy(SalaryPolicy):
        Â  Â  def __init__(self, weekly_salary, commission):
        Â  Â  Â  Â  super().__init__(weekly_salary)
        Â  Â  Â  Â  self.commission = commission
        Â  Â  def calculate_payroll(self):
        Â  Â  Â  Â  fixed = super().calculate_payroll()
        Â  Â  Â  Â  return fixed + self.commission
        ```
